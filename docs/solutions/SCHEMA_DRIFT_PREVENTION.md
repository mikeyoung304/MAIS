# Schema Drift Prevention Strategy

> **SUPERSEDED (2026-01-23):** This document describes the OLD hybrid migration system.
> We have consolidated to **Prisma-only migrations**. See:
>
> - **[database-issues/migration-system-consolidation.md](./database-issues/migration-system-consolidation.md)** - The consolidation solution
> - **[CLAUDE.md Database Migrations section](/CLAUDE.md#database-migrations)** - Current single-pattern docs

**Date Created:** 2025-11-28
**Date Superseded:** 2026-01-23
**Severity:** Critical (historical reference only)
**Impact:** Database integrity, AI agent safety, production stability

---

## Executive Summary

This document prevents a critical issue where schema changes were made without corresponding migrations, creating the risk of:

- Destructive database resets via `migrate reset` on production-like databases
- AI agents incorrectly assuming schema state
- Data corruption from schema/code mismatches
- Loss of trust in automated tooling

**Root Causes:**

1. Hybrid migration system (manual SQL + Prisma) wasn't documented
2. No pre-commit checks to detect schema drift
3. AI agents given unsafe database operations without safety gates
4. Missing CI/CD validation of schema consistency

**Key Prevention Strategies:**

- Detect which migration pattern to use (manual SQL vs Prisma)
- Pre-commit hooks to catch schema drift
- CI/CD gates to prevent unsafe operations
- Safe practices for AI agent database interactions
- Enhanced CLAUDE.md documentation

---

## Part 1: Detecting Migration Pattern Usage

### Current Migration Architecture

The MAIS codebase uses a **hybrid migration system**:

```
server/prisma/migrations/
â”œâ”€â”€ 20251016140827_initial_schema/
â”‚   â””â”€â”€ migration.sql                 # Prisma-generated migration
â”œâ”€â”€ 01_add_webhook_events.sql         # Manual raw SQL
â”œâ”€â”€ 02_add_performance_indexes.sql    # Manual raw SQL
â”œâ”€â”€ 03_add_multi_tenancy.sql          # Manual raw SQL
â””â”€â”€ 07_add_scheduling_platform.sql    # Manual raw SQL
```

**Two Migration Patterns Exist:**

#### Pattern A: Prisma Migrations (Version-based)

- Directory format: `{timestamp}_{description}/migration.sql`
- Uses `prisma migrate` commands
- Tracked in `_prisma_migrations` table
- Generated by Prisma from schema.prisma
- Stored in versioned directories

**Example:**

```
server/prisma/migrations/20251016140827_initial_schema/migration.sql
```

#### Pattern B: Manual SQL (Sequential)

- File format: `{number}_{description}.sql` (01*, 02*, etc.)
- Applied manually via `psql` or database tools
- NOT tracked by Prisma migrations system
- Must be applied in order
- Direct SQL without Prisma translation

**Example:**

```
server/prisma/migrations/07_add_scheduling_platform.sql
```

### Decision Tree: Which Pattern to Use

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  "I need to change the database schema"                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                           â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ Change affects â”‚         â”‚ Cannot express â”‚
            â”‚ Prisma schema  â”‚         â”‚ in Prisma?     â”‚
            â”‚ (tables, cols) â”‚         â”‚ (extensions,   â”‚
            â”‚                â”‚         â”‚ advisory locks)â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ YES                       â”‚ YES
                    â”‚                           â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   Use PATTERN B: Manual Raw SQL              â”‚
            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚ 1. Check migration_lock.toml for next       â”‚
            â”‚    version number                           â”‚
            â”‚ 2. Create: {next_num}_{description}.sql     â”‚
            â”‚ 3. Write idempotent SQL:                    â”‚
            â”‚    - Use IF EXISTS / IF NOT EXISTS          â”‚
            â”‚    - Use DO $$ blocks for conditionals      â”‚
            â”‚ 4. Apply: npx prisma db execute --file ...  â”‚
            â”‚    (NOT psql - has IPv6 issues w/ Supabase) â”‚
            â”‚ 5. Test on dev database first               â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚ NO (Can express in Prisma)
                    â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   Use PATTERN A: Prisma Migrate              â”‚
            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚ 1. Edit server/prisma/schema.prisma          â”‚
            â”‚ 2. Run: npm exec prisma migrate dev          â”‚
            â”‚    --name descriptive_name                   â”‚
            â”‚ 3. Prisma generates migration.sql            â”‚
            â”‚ 4. Review generated SQL                      â”‚
            â”‚ 5. Tests run automatically                   â”‚
            â”‚ 6. Verify with: npm exec prisma studio      â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Decision Guide Table

| Scenario                    | Pattern | Reason                             | Example                               |
| --------------------------- | ------- | ---------------------------------- | ------------------------------------- |
| Add column to Booking table | A       | Prisma supports columns            | `ADD COLUMN bookingType TEXT`         |
| Add enum type (BookingType) | B       | Prisma can't create enums in-place | `CREATE TYPE BookingType AS ENUM`     |
| Create new table (Service)  | A       | Prisma supports new tables         | `CREATE TABLE Service`                |
| Add PostgreSQL extension    | B       | Not supported by Prisma            | `CREATE EXTENSION IF NOT EXISTS`      |
| Add performance index       | B       | Custom indexes outside Prisma      | `CREATE INDEX on Booking(tenantId)`   |
| Add RLS policies            | B       | Not supported by Prisma            | `ALTER TABLE ... ENABLE ROW SECURITY` |
| Add unique constraint       | A       | Prisma supports via @@unique       | `@@unique([tenantId, slug])`          |
| Advisory locks usage        | B       | Database-specific feature          | `SELECT pg_advisory_xact_lock()`      |
| Add foreign key             | A       | Prisma supports @relation          | `@relation(fields: [tenantId])`       |
| Complex data migration      | B       | Requires procedural SQL            | `UPDATE ... WHERE ... CASE WHEN`      |

---

## Part 2: Pre-Commit Checks to Detect Schema Drift

### Pre-Commit Hook: Schema Drift Detection

Create file: `/Users/mikeyoung/CODING/MAIS/.husky/pre-commit` or `.git/hooks/pre-commit`

```bash
#!/bin/bash
# pre-commit-schema-drift.sh
# Prevents schema.prisma changes without corresponding migrations

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}ğŸ” Checking for schema drift...${NC}"

# Check if schema.prisma was modified
if git diff --cached --name-only | grep -q "server/prisma/schema.prisma"; then
  SCHEMA_MODIFIED=true
  echo -e "${YELLOW}â„¹ï¸  schema.prisma was modified${NC}"
else
  SCHEMA_MODIFIED=false
fi

# Check if migrations were created
MIGRATIONS_CREATED=false
if git diff --cached --name-only | grep -q "server/prisma/migrations/"; then
  MIGRATIONS_CREATED=true
  echo -e "${GREEN}âœ… Migrations found${NC}"
fi

# Check if manual SQL migrations exist
MANUAL_MIGRATIONS=false
if git diff --cached --name-only | grep -qE "server/prisma/migrations/[0-9]+_.*\.sql$"; then
  MANUAL_MIGRATIONS=true
fi

# Validation logic
if [ "$SCHEMA_MODIFIED" = true ] && [ "$MIGRATIONS_CREATED" = false ] && [ "$MANUAL_MIGRATIONS" = false ]; then
  echo -e "${RED}âŒ SCHEMA DRIFT DETECTED!${NC}"
  echo -e "${RED}Error: schema.prisma was modified but no migrations were created.${NC}"
  echo ""
  echo "Fix this by choosing ONE of the following:"
  echo ""
  echo "Option 1: Create Prisma migration (for table/column changes)"
  echo "  npm exec prisma migrate dev --name your_change_name"
  echo ""
  echo "Option 2: Create manual SQL migration (for enums, indexes, extensions)"
  echo "  1. Find next version number: ls server/prisma/migrations/ | grep '^[0-9]' | tail -1"
  echo "  2. Create: server/prisma/migrations/NN_your_change_name.sql"
  echo "  3. Add idempotent SQL (use IF EXISTS, DO \$\$ blocks)"
  echo "  4. Apply: psql \$DATABASE_URL < server/prisma/migrations/NN_your_change_name.sql"
  echo ""
  echo "Option 3: Undo schema.prisma change (if it was accidental)"
  echo "  git checkout server/prisma/schema.prisma"
  echo ""
  exit 1
fi

echo -e "${GREEN}âœ… Schema drift check passed${NC}"
exit 0
```

### Installation Instructions

```bash
# 1. Make script executable
chmod +x .git/hooks/pre-commit

# 2. (Optional) Use husky for better management
npm install -D husky
npx husky install
npx husky add .husky/pre-commit "bash .git/hooks/pre-commit"

# 3. Test the hook
git add server/prisma/schema.prisma
git commit -m "test: trigger hook"  # Should fail with schema drift message
```

### What the Hook Catches

âœ… **Will Prevent:**

- `schema.prisma` modified without migrations
- Committing schema changes without safety net
- AI agents accidentally skipping migrations

âŒ **Will Allow:**

- Schema changes with Prisma migrations
- Schema changes with manual SQL migrations
- Non-schema files being committed

---

## Part 3: CI/CD Safety Gates

### GitHub Actions: Schema Consistency Validation

Create file: `/Users/mikeyoung/CODING/MAIS/.github/workflows/schema-validation.yml`

```yaml
name: Schema Validation

on:
  pull_request:
    paths:
      - 'server/prisma/schema.prisma'
      - 'server/prisma/migrations/**'
  push:
    branches:
      - main

jobs:
  schema-drift-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Full history for comparison

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Check for schema drift
        working-directory: server
        run: |
          # Get list of modified files
          MODIFIED=$(git diff origin/main..HEAD --name-only | grep "prisma/" || echo "")

          if echo "$MODIFIED" | grep -q "schema.prisma"; then
            SCHEMA_MODIFIED=true
          else
            SCHEMA_MODIFIED=false
          fi

          if echo "$MODIFIED" | grep -q "migrations/"; then
            MIGRATIONS_CREATED=true
          else
            MIGRATIONS_CREATED=false
          fi

          if [ "$SCHEMA_MODIFIED" = true ] && [ "$MIGRATIONS_CREATED" = false ]; then
            echo "âŒ SCHEMA DRIFT: schema.prisma changed but no migrations created"
            exit 1
          fi
          echo "âœ… Schema consistency check passed"

  prisma-format-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Check Prisma schema format
        working-directory: server
        run: npx prisma format --check

      - name: Validate Prisma schema
        working-directory: server
        run: npx prisma validate

  migration-validation:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Check migration status
        working-directory: server
        env:
          DATABASE_URL: 'postgresql://postgres:postgres@localhost:5432/test_db'
          DIRECT_URL: 'postgresql://postgres:postgres@localhost:5432/test_db'
        run: |
          npx prisma migrate status || {
            echo "âŒ Migration status check failed"
            echo "Run: npm exec prisma migrate dev --name <migration_name>"
            exit 1
          }

      - name: Validate migration can be applied
        working-directory: server
        env:
          DATABASE_URL: 'postgresql://postgres:postgres@localhost:5432/test_db'
          DIRECT_URL: 'postgresql://postgres:postgres@localhost:5432/test_db'
        run: |
          npm exec prisma migrate deploy || {
            echo "âŒ Migration deployment failed"
            exit 1
          }

      - name: Generate Prisma Client
        working-directory: server
        run: npx prisma generate

      - name: Verify schema type safety
        working-directory: server
        run: npm run typecheck

  ai-safety-gates:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Prevent destructive migration commands
        run: |
          # Scan for dangerous patterns in PR description
          echo "ğŸš¨ SAFETY CHECK: Scanning for dangerous patterns..."

          # Check for 'migrate reset' command (only safe on dev DB)
          if grep -r "migrate reset" . --include="*.md" --include="*.sh" 2>/dev/null; then
            echo "âš ï¸  Found 'migrate reset' - ensure this is dev/test only, NOT production"
          fi

          # Check for unsafe database operations
          if grep -r "DROP TABLE\|DROP DATABASE\|TRUNCATE" . --include="*.sql" 2>/dev/null; then
            echo "âš ï¸  Found destructive SQL - verify this is intentional and safe"
          fi

      - name: Validate CLAUDE.md has migration guidance
        run: |
          if grep -q "When Modifying Database Schema" CLAUDE.md; then
            echo "âœ… CLAUDE.md has schema modification guidance"
          else
            echo "âš ï¸  CLAUDE.md missing schema modification guidance"
          fi
```

### What These Gates Catch

âœ… **Will Prevent:**

- Schema changes without migrations
- Malformed Prisma schema syntax
- Migrations that can't be applied
- TypeScript type safety issues from schema
- Dangerous destructive SQL

âŒ **Will Allow:**

- Valid schema + migration pairs
- Proper Prisma formatting
- Backward-compatible changes

---

## Part 4: Safe Practices for AI Agent Database Interactions

### Safety Rule: Never Run Destructive Commands Without User Consent

AI agents should NEVER run these commands:

- âŒ `prisma migrate reset` (destructive - drops database)
- âŒ `prisma db push --force-reset` (destructive)
- âŒ DROP TABLE, DROP DATABASE, TRUNCATE (destructive)
- âŒ Any write operations to production database

### Safe Database Operations for AI

**SAFE Operations:**

```bash
âœ… npm exec prisma migrate status      # Read-only: check migration status
âœ… npm exec prisma studio             # Read-only: view data
âœ… npm exec prisma generate           # Regenerate client (no DB changes)
âœ… npm exec prisma validate           # Validate schema (no DB changes)
âœ… npm test                            # Run tests (uses test DB)
âœ… npm run typecheck                   # TypeScript validation
```

**UNSAFE Operations (AI should propose, not execute):**

```bash
âŒ npm exec prisma migrate dev         # Creates migration and applies it
âŒ npm exec prisma migrate deploy      # Applies migrations to production
âŒ npm exec prisma migrate reset       # Drops and recreates database
âŒ npm exec prisma db push             # Modifies database schema
âŒ npm exec prisma db seed             # Inserts data
```

### Template: AI Agent Safety Instructions

Add to `.claude/CLAUDE.md` or system prompts:

```markdown
## Safe Database Operations for AI Agents

### When You Detect Schema Drift

If schema.prisma has been modified but no migrations exist:

**DO NOT RUN:**
```

npm exec prisma migrate reset # âŒ DESTRUCTIVE - FORBIDDEN
npm exec prisma db push --force-reset # âŒ DESTRUCTIVE - FORBIDDEN

````

**INSTEAD:**

1. First, determine which migration pattern to use
2. Look up the decision tree in SCHEMA_DRIFT_PREVENTION.md
3. Propose the migration to the user
4. Let the user run: `npm exec prisma migrate dev --name ...`

### Examples

**Example 1: Adding a column to Package table**

Schema change:
```prisma
model Package {
  ...
  new_field String?  // â† Added
}
````

Correct action:

```bash
npm exec prisma migrate dev --name add_new_field_to_package
# AI: "I've created a migration. Run the command above, then test with: npm test"
```

**Example 2: Adding an enum (requires manual SQL)**

Schema change:

```prisma
enum PackageStatus {
  ACTIVE
  ARCHIVED
}
```

Correct action:

```
1. Identify this needs manual SQL (enums can't be created by Prisma)
2. Create: server/prisma/migrations/08_add_package_status_enum.sql
3. Write idempotent SQL with IF EXISTS checks
4. Propose to user: "Run: psql $DATABASE_URL < migrations/08_*.sql"
5. Then: npm exec prisma generate
```

### When in Doubt

If unsure whether to use Pattern A or B:

1. Check SCHEMA_DRIFT_PREVENTION.md Decision Tree
2. Ask the user: "Should I use Prisma migrate or manual SQL?"
3. Never assume - always verify before running commands

````

---

## Part 5: CLAUDE.md Documentation Updates

### Add to CLAUDE.md: Database Schema Modification Guide

```markdown
## When Modifying Database Schema

### The Hybrid Migration System

MAIS uses a hybrid migration system with two patterns:

**Pattern A: Prisma Migrations** (for table/column changes)
- Run: `npm exec prisma migrate dev --name descriptive_name`
- Prisma auto-generates from schema.prisma
- Creates timestamped directory: `migrations/20251128123456_descriptive_name/`

**Pattern B: Manual Raw SQL** (for enums, indexes, extensions)
- Create: `server/prisma/migrations/NN_descriptive_name.sql`
- Must be applied manually: `psql $DATABASE_URL < file.sql`
- Must be idempotent: use IF EXISTS, DO $$ blocks
- Must be sequential: apply in numeric order

### Quick Decision Guide

| Change Type | Pattern | Example |
|-------------|---------|---------|
| Add/remove column | A | `bookingType String?` |
| Add/remove table | A | `model NewTable { ... }` |
| Add enum | B | `CREATE TYPE MyEnum AS ENUM (...)` |
| Add index | B | `CREATE INDEX on Table(column)` |
| Add constraint | A | `@@unique([tenantId, slug])` |
| Add foreign key | A | `@relation(fields: [tenantId])` |
| RLS policy | B | `ALTER TABLE ... ENABLE ROW SECURITY` |
| PostgreSQL extension | B | `CREATE EXTENSION ...` |

### Critical Rules

1. **Never skip migrations**: Schema changes MUST have a corresponding migration
2. **Always test locally first**: Apply migration on dev database before committing
3. **Use idempotent SQL**: Manual migrations must be safe to re-run
4. **Don't modify applied migrations**: If migration is committed, never edit it
5. **Update repositories**: After schema changes, update Prisma repository files

### Step-by-Step: Add a Column

```bash
# 1. Edit schema.prisma
nano server/prisma/schema.prisma

# 2. Add new field
# model Package {
#   ...
#   newField String?  â† Add this line
# }

# 3. Create migration
npm exec prisma migrate dev --name add_new_field_to_package

# 4. Prisma generates migration.sql, applies it, regenerates Prisma Client
# â†’ Tests run automatically

# 5. Verify with Prisma Studio
npm exec prisma studio

# 6. Commit schema.prisma + migration directory
git add server/prisma/
git commit -m "feat: add newField to Package model"
````

### Step-by-Step: Add an Enum (Manual SQL)

```bash
# 1. Edit schema.prisma
nano server/prisma/schema.prisma

# 2. Add enum definition
# enum BookingType {
#   DATE
#   TIMESLOT
# }

# 3. Find next migration number
ls server/prisma/migrations/ | grep '^[0-9]' | tail -1
# Output: 07_add_scheduling_platform.sql â†’ Next is 08

# 4. Create idempotent SQL file
cat > server/prisma/migrations/08_add_booking_type_enum.sql << 'EOF'
-- Create BookingType enum if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'BookingType') THEN
    CREATE TYPE "BookingType" AS ENUM ('DATE', 'TIMESLOT');
    RAISE NOTICE 'Created BookingType enum';
  ELSE
    RAISE NOTICE 'BookingType enum already exists';
  END IF;
END $$;

-- Alter Booking table to add bookingType column
ALTER TABLE "Booking"
  ADD COLUMN IF NOT EXISTS "bookingType" "BookingType" NOT NULL DEFAULT 'DATE';
EOF

# 5. Apply migration locally (use prisma db execute, NOT psql - IPv6 issues)
npx prisma db execute --file server/prisma/migrations/08_add_booking_type_enum.sql

# 6. Regenerate Prisma Client
npm exec prisma generate

# 7. Verify with tests
npm test

# 8. Commit
git add server/prisma/migrations/08_*.sql server/prisma/schema.prisma
git commit -m "feat: add BookingType enum and bookingType column to Booking"
```

### Troubleshooting Schema Changes

**Problem: "prisma migrate status" shows pending migrations**

```bash
# Solution: Apply migrations locally
npm exec prisma migrate dev

# If you want to start fresh:
npm exec prisma db push
```

**Problem: "Cannot find generated Prisma Client"**

```bash
# Solution: Regenerate after schema changes
npm exec prisma generate
```

**Problem: "Unique constraint violation after migration"**

```bash
# This means the migration found duplicate data
# Solution: Manual data cleanup or use data migration in SQL
# Add WHERE clause to migration or create data cleanup step
```

**Problem: "ALTER TABLE... ADD COLUMN fails with 'already exists'"**

```bash
# Solution: Use idempotent SQL
ALTER TABLE "TableName"
  ADD COLUMN IF NOT EXISTS "columnName" TEXT;
```

### Pre-Commit Hook

There's a pre-commit hook that prevents schema drift:

```bash
.git/hooks/pre-commit  # Checks schema.prisma vs migrations
```

This hook prevents commits that change schema.prisma without creating migrations.

If the hook blocks your commit:

1. Verify you created a migration: `ls server/prisma/migrations/`
2. If you need to undo the schema change: `git checkout server/prisma/schema.prisma`
3. If you need to create the migration: see step-by-step guides above

### Safety Rules

- **Never run `prisma migrate reset` on production data** (destructive)
- **Always test migrations on dev DB first** before pushing to main
- **Never modify migrations after they're committed** (breaks for other developers)
- **Always regenerate Prisma Client after migrations** (`npm exec prisma generate`)

````

---

## Part 6: Test Cases to Catch Schema Drift

### Unit Test: Schema Consistency Validator

Create file: `/Users/mikeyoung/CODING/MAIS/server/test/schema-consistency.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import * as fs from 'fs';
import * as path from 'path';

describe('Schema Consistency', () => {
  const schemePath = path.join(__dirname, '../prisma/schema.prisma');
  const migrationsPath = path.join(__dirname, '../prisma/migrations');

  it('should have schema.prisma file', () => {
    expect(fs.existsSync(schemePath)).toBe(true);
  });

  it('should have migrations directory', () => {
    expect(fs.existsSync(migrationsPath)).toBe(true);
  });

  it('should not have empty schema.prisma', () => {
    const schema = fs.readFileSync(schemePath, 'utf-8');
    expect(schema.length).toBeGreaterThan(100);
  });

  it('should have numbered migration files', () => {
    const files = fs.readdirSync(migrationsPath);
    const sqlFiles = files.filter(f => f.endsWith('.sql'));
    const numericFiles = sqlFiles.filter(f => /^\d+_/.test(f));

    // Expect at least some manual SQL migrations
    expect(numericFiles.length).toBeGreaterThan(0);

    // Verify they're numbered sequentially (01_, 02_, 03_, etc.)
    numericFiles.forEach(file => {
      const num = parseInt(file.split('_')[0]);
      expect(num).toBeGreaterThanOrEqual(0);
    });
  });

  it('should have valid migration files (not empty)', () => {
    const files = fs.readdirSync(migrationsPath);
    const sqlFiles = files.filter(f => f.endsWith('.sql'));

    sqlFiles.forEach(file => {
      const filePath = path.join(migrationsPath, file);
      const content = fs.readFileSync(filePath, 'utf-8');
      expect(content.trim().length).toBeGreaterThan(0);
    });
  });

  it('should use idempotent SQL in manual migrations', () => {
    const files = fs.readdirSync(migrationsPath);
    const manualSqlFiles = files.filter(f => /^\d+_/.test(f));

    const idempotentPatterns = [
      'IF EXISTS',
      'IF NOT EXISTS',
      'CREATE TABLE IF NOT EXISTS',
      'DROP TABLE IF EXISTS',
      'DO $$',  // PL/pgSQL blocks for conditional logic
    ];

    manualSqlFiles.forEach(file => {
      const filePath = path.join(migrationsPath, file);
      const content = fs.readFileSync(filePath, 'utf-8').toUpperCase();

      // At least one idempotent pattern should be present
      const hasIdempotent = idempotentPatterns.some(pattern =>
        content.includes(pattern)
      );

      expect(hasIdempotent).toBe(true);
    });
  });

  it('should not have schema.prisma changes without migrations', () => {
    // This test verifies the pre-commit hook is working
    // In CI, it checks git diff to ensure migrations exist

    // Note: This requires git to be available in test environment
    try {
      const { execSync } = require('child_process');

      // Check git status (uncommitted changes)
      const status = execSync('git status --porcelain server/prisma/', {
        cwd: path.join(__dirname, '../..'),
        encoding: 'utf-8'
      });

      if (status.includes('schema.prisma')) {
        expect(status).toContain('migrations/');
      }
    } catch (err) {
      // Skip if git not available (e.g., in some CI environments)
      console.log('Git not available for schema drift check');
    }
  });

  it('should not have uncommitted migrations', () => {
    // Migrations should be committed with schema changes
    const schema = fs.readFileSync(schemePath, 'utf-8');
    const migrations = fs.readdirSync(migrationsPath);

    // If schema exists (should always be true), migrations should exist
    expect(schema.length).toBeGreaterThan(0);
    expect(migrations.length).toBeGreaterThan(0);
  });
});
````

### Integration Test: Migration Application Success

Create file: `/Users/mikeyoung/CODING/MAIS/server/test/integration/migration-validation.integration.spec.ts`

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { PrismaClient } from '../../src/generated/prisma';
import * as path from 'path';
import * as fs from 'fs';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

describe('Migration Validation', () => {
  let prisma: PrismaClient;

  beforeAll(async () => {
    // Skip if DATABASE_URL not set (local dev)
    if (!process.env.DATABASE_URL) {
      console.log('Skipping migration tests (DATABASE_URL not set)');
      return;
    }

    prisma = new PrismaClient();
  });

  afterAll(async () => {
    if (prisma) {
      await prisma.$disconnect();
    }
  });

  it('should have all migrations applied', async () => {
    if (!process.env.DATABASE_URL) {
      console.log('Skipping test');
      return;
    }

    try {
      // Check migration status
      const { stdout } = await execAsync('npm exec prisma migrate status', {
        cwd: path.dirname(__dirname),
      });

      // If no "pending migrations" message, all migrations are applied
      expect(stdout).not.toContain('pending');
    } catch (err: any) {
      // Non-zero exit code means migrations are out of sync
      expect(err.message).not.toContain('pending');
    }
  });

  it('should have valid Prisma schema', async () => {
    if (!process.env.DATABASE_URL) {
      console.log('Skipping test');
      return;
    }

    try {
      // Validate Prisma schema syntax
      await execAsync('npm exec prisma validate', {
        cwd: path.dirname(__dirname),
      });
    } catch (err: any) {
      expect(err).toBeNull();
    }
  });

  it('should have all required tables', async () => {
    if (!process.env.DATABASE_URL) {
      console.log('Skipping test');
      return;
    }

    // Verify critical tables exist
    const requiredTables = [
      'Tenant',
      'User',
      'Package',
      'Booking',
      'Service',
      'AvailabilityRule',
      'WebhookEvent',
    ];

    for (const table of requiredTables) {
      // Try to query the table (will fail if it doesn't exist)
      try {
        await prisma.$executeRawUnsafe(`SELECT 1 FROM "${table}" LIMIT 1`);
      } catch (err: any) {
        expect(err.message).not.toContain('does not exist');
      }
    }
  });

  it('should have correct column types', async () => {
    if (!process.env.DATABASE_URL) {
      console.log('Skipping test');
      return;
    }

    // Verify Booking table has bookingType column (from manual migration)
    const result = await prisma.$queryRaw<any[]>`
      SELECT column_name, data_type
      FROM information_schema.columns
      WHERE table_name = 'Booking'
      AND column_name = 'bookingType'
    `;

    expect(result.length).toBe(1);
    expect(result[0].data_type).toBe('USER-DEFINED'); // It's an enum
  });
});
```

---

## Part 7: Quick Reference Checklist

### When You Modify schema.prisma

- [ ] Check decision tree: Prisma migration vs. manual SQL?
- [ ] Create migration (Pattern A) OR manual SQL file (Pattern B)
- [ ] Test locally: `npm test`
- [ ] Verify with Prisma Studio: `npm exec prisma studio`
- [ ] Regenerate client: `npm exec prisma generate`
- [ ] Commit schema.prisma + migration files together
- [ ] Pre-commit hook validates migration exists
- [ ] CI/CD validates migration can be applied

### Safe Database Commands (AI Agents)

âœ… Safe to run:

- `npm exec prisma migrate status`
- `npm exec prisma validate`
- `npm exec prisma studio`
- `npm exec prisma generate`
- `npm run typecheck`
- `npm test`

âŒ Never run without user consent:

- `npm exec prisma migrate dev`
- `npm exec prisma migrate deploy`
- `npm exec prisma migrate reset` (destructive)
- `npm exec prisma db push`
- Any DROP/TRUNCATE SQL

### When AI Agent Detects Schema Drift

1. Check if schema.prisma was modified
2. Check if migrations directory was updated
3. If NO migrations found:
   - Propose migration to user
   - Ask user to run: `npm exec prisma migrate dev --name ...`
   - Do NOT run it yourself

---

## Part 8: Documentation References

- `/Users/mikeyoung/CODING/MAIS/CLAUDE.md` - Updated with schema modification guide
- `/Users/mikeyoung/CODING/MAIS/DECISIONS.md` - ADRs for database patterns
- `/Users/mikeyoung/CODING/MAIS/server/prisma/schema.prisma` - Current schema
- `/Users/mikeyoung/CODING/MAIS/.git/hooks/pre-commit` - Pre-commit validation hook
- `.github/workflows/schema-validation.yml` - CI/CD gates

---

## Implementation Checklist

- [ ] Add SCHEMA_DRIFT_PREVENTION.md (this file)
- [ ] Update CLAUDE.md with "When Modifying Database Schema" section
- [ ] Install pre-commit hook (`.git/hooks/pre-commit`)
- [ ] Add GitHub Actions workflow (`.github/workflows/schema-validation.yml`)
- [ ] Add test cases (`schema-consistency.test.ts`, `migration-validation.integration.spec.ts`)
- [ ] Update .gitignore to exclude unwanted migration files
- [ ] Document hybrid migration system in README
- [ ] Train team on decision tree and patterns
- [ ] Update AI agent instructions with safety rules

---

## References

- Prisma Migrations: https://www.prisma.io/docs/orm/prisma-migrate/overview
- PostgreSQL Manual: https://www.postgresql.org/docs/current/sql-syntax.html
- Advisory Locks: https://www.postgresql.org/docs/current/explicit-locking.html#ADVISORY-LOCKS
- Pre-commit hooks: https://git-scm.com/docs/githooks
- GitHub Actions: https://docs.github.com/en/actions

---

**Last Updated:** 2025-11-28
**Next Review:** 2025-12-28
