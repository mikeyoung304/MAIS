---
title: 'Prisma Major Version Upgrade Build Failure Prevention'
category: database-issues
severity: P1
status: resolved
date_solved: 2026-01-02
tags:
  - prisma
  - prisma-7
  - build-failures
  - npm-workspaces
  - entry-point-changes
  - deployment
components:
  - server/scripts/prisma-postgenerate.js
  - server/src/db.ts
  - server/package.json
  - render.yaml
symptoms:
  - "Cannot find module './generated/prisma'" on deployment
  - Build fails on Render but works locally (cached index.ts)
  - "Module not found: Error: Can't resolve './generated/prisma'" (Next.js)
  - Prisma 6 imports break after upgrading to Prisma 7
  - Existing codebase uses `from './generated/prisma'` but file doesn't exist
related_docs:
  - docs/solutions/database-issues/prisma-7-json-type-breaking-changes-MAIS-20260102.md
  - docs/solutions/database-issues/prisma-upgrade-checklist-MAIS-20260102.md
  - docs/solutions/deployment-issues/vercel-nextjs-npm-workspaces-root-directory-MAIS-20251226.md
---

# Prisma Major Version Upgrade Build Failure Prevention

## Problem Summary

When upgrading from Prisma 6 to Prisma 7 (or any major version with breaking entry point changes), builds fail in CI/deployment environments but work locally. This happens because:

1. **Entry point changed:** Prisma 6 generated `src/generated/prisma/index.ts`, Prisma 7 generates `src/generated/prisma/client.ts`
2. **Local cache masks issue:** Your local `node_modules` still has the old `index.ts` from the previous build
3. **Clean CI fails:** CI environments delete `node_modules`, rebuild from scratch, and the missing `index.ts` causes module resolution failures
4. **Render deployment blocked:** Deployment fails before app starts because imports cannot be resolved

## Root Cause Analysis

### The Prisma Generation Problem

```bash
# Prisma 6 entry point
server/src/generated/prisma/
├── index.ts          # Main entry point (generated)
├── client.ts
├── types/
└── runtime/

# Prisma 7 entry point
server/src/generated/prisma/
├── client.ts         # New main entry point (generated)
├── index.ts          # GONE - no longer generated!
├── types/
└── runtime/
```

When Prisma 7 generates code, it **removes** the `index.ts` file because it's now in the `.gitignore`. Your existing codebase still imports from it, causing failures in clean builds.

### Why It Works Locally But Fails in CI

```
Local Build (Works)
├─ npm install
├─ node_modules/ already has index.ts from previous build
├─ Build succeeds (uses cached file)
└─ App runs

CI Build (Fails)
├─ rm -rf node_modules
├─ npm install (clean slate)
├─ prisma generate (creates only client.ts, no index.ts)
├─ TypeScript can't find ./generated/prisma/index.ts import
├─ Build fails: Cannot find module
└─ Deployment blocked
```

## Solution: Postgenerate Script + Wrapper Module

### Step 1: Create Postgenerate Script

Create `server/scripts/prisma-postgenerate.js`:

```javascript
#!/usr/bin/env node
/**
 * Prisma 7 Post-Generate Script
 *
 * Creates a barrel file (index.ts) in the generated prisma directory
 * to maintain backward compatibility with Prisma 6 import patterns.
 *
 * In Prisma 7, the entry point changed from index.ts to client.ts.
 * This script recreates the index.ts after each `prisma generate`.
 */

import { writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const generatedDir = join(__dirname, '../src/generated/prisma');
const indexPath = join(generatedDir, 'index.ts');

const barrelContent = `/**
 * Prisma 7 Barrel File - Backward Compatibility Layer
 *
 * AUTO-GENERATED by scripts/prisma-postgenerate.js
 * DO NOT EDIT MANUALLY - This file is recreated after each prisma generate.
 *
 * In Prisma 7, the main entry point changed from index.ts to client.ts.
 * This barrel file re-exports everything from client.ts to maintain
 * backward compatibility with existing imports.
 */

export * from './client';
`;

try {
  writeFileSync(indexPath, barrelContent, 'utf-8');
  console.log('✅ Created Prisma barrel file: src/generated/prisma/index.ts');
} catch (error) {
  console.error('❌ Failed to create Prisma barrel file:', error);
  process.exit(1);
}
```

**Key points:**

- ESM import/export syntax (matches `"type": "module"` in package.json)
- Uses `dirname(fileURLToPath(import.meta.url))` for ESM directory resolution
- Exits with code 1 on failure so build stops early (fail fast)
- Creates exact same barrel re-export pattern each time

### Step 2: Wire Script to Package.json

Update `server/package.json`:

```json
{
  "scripts": {
    "prisma:generate": "prisma generate && node scripts/prisma-postgenerate.js",
    "build": "npm run prisma:generate && tsc -b"
  }
}
```

**Critical:** The build script MUST call `prisma:generate` first. This ensures:

1. Prisma generates code
2. Postgenerate script creates the barrel file
3. TypeScript compiles with the barrel file in place

### Step 3: Create Wrapper Module (Optional but Recommended)

Create `server/src/db.ts`:

````typescript
/**
 * Prisma Client Re-export Module
 *
 * This file re-exports everything from the Prisma 7 generated client.
 * In Prisma 7, the entry point changed from index.ts to client.ts.
 * This wrapper provides a stable import path that won't be overwritten
 * by `prisma generate`.
 *
 * Usage:
 * ```typescript
 * // Instead of: import { PrismaClient } from './generated/prisma'
 * import { PrismaClient, Prisma } from './db'
 * ```
 */

export * from './generated/prisma/client';
````

**Benefits of the wrapper:**

- Single import path across codebase: `import { PrismaClient } from './db'`
- Isolated from generated code changes
- Easier to swap implementations (mock vs real) in tests
- Cleaner than scattered imports from `/generated/prisma`

### Step 4: Update All Imports

Convert existing imports to use the wrapper (or barrel file):

```typescript
// Before (Prisma 6)
import { PrismaClient, Prisma } from './generated/prisma';

// After (Prisma 7 - with wrapper module)
import { PrismaClient, Prisma } from './db';

// After (Prisma 7 - with barrel file only)
import { PrismaClient, Prisma } from './generated/prisma';
```

## Prevention Checklist

### Before Upgrading Prisma

- [ ] **Document current version:** `npm list prisma > PRISMA_VERSION_BEFORE.txt`
- [ ] **Check release notes:** Visit [prisma.io/docs/orm/more/upgrade-guide](https://www.prisma.io/docs/orm/more/upgrade-guide)
- [ ] **Search for breaking changes:** Entry point changes, JSON type changes, API removals
- [ ] **Identify entry point changes:** Will Prisma 7+ change where code is generated?
- [ ] **Grep for imports:** `grep -r "from './generated/prisma'" server/src/`
- [ ] **Run baseline tests:** `npm test 2>&1 | tee BEFORE_UPGRADE.log`

### During Upgrade

- [ ] **Create postgenerate script:** `server/scripts/prisma-postgenerate.js`
- [ ] **Wire to package.json:** Update `prisma:generate` script
- [ ] **Update version:** `npm install prisma@latest @prisma/client@latest`
- [ ] **Regenerate:** `npm run prisma:generate` (postgenerate fires automatically)
- [ ] **Verify barrel file:** Check that `src/generated/prisma/index.ts` exists
- [ ] **Type check:** `npm run typecheck`
- [ ] **Build locally:** `npm run build` (must work in clean shell)

### After Upgrade

- [ ] **Clean environment test:** `rm -rf node_modules && npm install && npm run build`
- [ ] **CI simulation:** Run build in docker or isolated environment
- [ ] **Test imports:** Verify `import { PrismaClient } from './db'` works
- [ ] **Run tests:** `npm test` (full suite)
- [ ] **Document:** Add entry point info to CLAUDE.md for team

### In CI/Deployment (Render, Vercel, etc.)

- [ ] **Build script includes postgenerate:** `npm run prisma:generate && tsc -b`
- [ ] **No npm cache:** Use `--prefer-offline false` or clear cache
- [ ] **Fresh node_modules:** Delete before build
- [ ] **Order matters:** Generate → Type check → Build
- [ ] **Test deploy:** Manual deployment before merging to main

## Implementation Example: MAIS Project

The MAIS project implements this pattern:

**1. Postgenerate Script:**

```bash
server/scripts/prisma-postgenerate.js
```

**2. Build Wiring:**

```json
{
  "scripts": {
    "prisma:generate": "prisma generate && node scripts/prisma-postgenerate.js",
    "build": "npm run prisma:generate && tsc -b"
  }
}
```

**3. Wrapper Module:**

```typescript
// server/src/db.ts
export * from './generated/prisma/client';
```

**4. Usage Across Codebase:**

```typescript
// server/src/di.ts
import { PrismaClient } from './db';

// server/src/routes/tenant-admin-billing.routes.ts
import { PrismaClient, Prisma } from './db';
```

## Testing the Fix

### Local Test (Immediate Feedback)

```bash
cd server

# 1. Clean build
rm -rf src/generated/
npm run prisma:generate

# 2. Verify barrel file exists
ls -la src/generated/prisma/index.ts
cat src/generated/prisma/index.ts

# 3. Type check
npm run typecheck

# 4. Build
npm run build

# 5. Verify import works
node -e "const { PrismaClient } = require('./dist/db.js'); console.log(PrismaClient.name);"
```

### CI Simulation (Realistic Test)

```bash
# Clean environment (no node_modules cache)
docker run -it --rm \
  -v $(pwd):/app \
  node:20 \
  bash -c "cd /app && npm ci && npm run build"
```

### Render-Specific Test

Render uses the build command from `render.yaml`:

```yaml
build:
  command: npm run build
```

To test locally:

```bash
# Simulate Render environment
npm ci --production=false  # Exact npm version lockfile
npm run build              # Must match render.yaml
```

## Common Mistakes to Avoid

### Mistake 1: Forgetting to Run Postgenerate

```bash
# ❌ WRONG - Generates code but doesn't create barrel file
npm exec prisma generate

# ✅ CORRECT - Generates code AND runs postgenerate
npm run prisma:generate
```

### Mistake 2: Only Testing Local Build

```bash
# ❌ WRONG - Uses cached node_modules
npm install
npm run build

# ✅ CORRECT - Clean environment
rm -rf node_modules
npm install
npm run build
```

### Mistake 3: Build Script Doesn't Call Generate

```json
{
  "scripts": {
    "prisma:generate": "prisma generate && node scripts/prisma-postgenerate.js",
    "build": "tsc -b"  // ❌ WRONG - skips generate step
  }
}

// ✅ CORRECT
{
  "scripts": {
    "build": "npm run prisma:generate && tsc -b"
  }
}
```

### Mistake 4: Postgenerate Script Not Executable

```bash
# Verify script has proper shebang and is executable
head -1 server/scripts/prisma-postgenerate.js  # Should be: #!/usr/bin/env node

# Make executable (if not already)
chmod +x server/scripts/prisma-postgenerate.js
```

### Mistake 5: Entry Point Not in .gitignore

The `src/generated/prisma/` directory and its generated files should be in `.gitignore`. The barrel file created by postgenerate is a special exception:

```
# .gitignore
src/generated/
!src/generated/prisma/index.ts  # Exception: barrel file needed for imports
```

Actually, better pattern: **Don't** add the barrel file to git. Instead, ensure it's always created during build:

```bash
# Cleaner approach: exclude all generated code
src/generated/

# Build process always creates what's needed
```

## Validation Commands

Run these commands to validate your fix:

```bash
# 1. Check postgenerate script syntax
node -c server/scripts/prisma-postgenerate.js

# 2. Check barrel file content
cat server/src/generated/prisma/index.ts

# 3. Verify exports are available
npm run typecheck

# 4. Check imports resolve
grep -r "from './db'" server/src/ | head -5

# 5. Full build test
npm run build

# 6. Count successful type checks
npm run typecheck 2>&1 | grep -c "error" | xargs -I {} test {} -eq 0 && echo "✓ All types check" || echo "✗ Type errors found"
```

## Metrics & Verification

### Before Fix

```
Local build: SUCCESS (uses cached index.ts)
CI build: FAILURE (Cannot find module './generated/prisma')
Deploy: BLOCKED by build failure
```

### After Fix

```
Local build: SUCCESS (postgenerate creates barrel file)
CI build: SUCCESS (postgenerate runs in clean environment)
Deploy: SUCCESS (Render build script includes prisma:generate)
```

## Related Documentation

- **Prisma 7 JSON Type Changes:** [prisma-7-json-type-breaking-changes-MAIS-20260102.md](./prisma-7-json-type-breaking-changes-MAIS-20260102.md)
- **Upgrade Checklist:** [prisma-upgrade-checklist-MAIS-20260102.md](./prisma-upgrade-checklist-MAIS-20260102.md)
- **Deployment Prevention:** [vercel-nextjs-npm-workspaces-root-directory-MAIS-20251226.md](../deployment-issues/vercel-nextjs-npm-workspaces-root-directory-MAIS-20251226.md)
- **Prisma Official:** [Upgrade Guide](https://www.prisma.io/docs/orm/more/upgrade-guide)

## Key Insights

### Why This Pattern Works

1. **Idempotent:** Postgenerate script creates the same file every build
2. **Isolated:** Doesn't interfere with Prisma's generated code
3. **Backward compatible:** Existing imports keep working
4. **Future-proof:** When Prisma changes entry points again, just update one script

### Why Entry Points Change

Major ORM versions often restructure code generation:

- **Prisma 6:** Single `index.ts` entry point
- **Prisma 7:** Splits into `client.ts` (main), other specialized files
- **Prisma 8+:** Might change again (possible monorepo structure, tree-shaking, etc.)

Always check release notes for entry point changes before upgrading.

### Defense-in-Depth

This solution uses multiple layers:

1. **Postgenerate script:** Ensures barrel file always exists
2. **Build script ordering:** Forces generate before compile
3. **Wrapper module:** Single import path (defensive against future changes)
4. **Clean environment testing:** Catches issues before deployment

## Verification Post-Implementation

After implementing this pattern:

```bash
# Test 1: Immediate - verify barrel file
npm run prisma:generate
test -f server/src/generated/prisma/index.ts && echo "✓ Barrel file created"

# Test 2: Type safety
npm run typecheck 2>&1 | grep -q "error TS" && echo "✗ Type errors" || echo "✓ Types pass"

# Test 3: Clean build (Docker/VM recommended)
docker run -v $(pwd):/app node:20 bash -c "cd /app && npm ci && npm run build" && echo "✓ Clean build passes"

# Test 4: Import resolution
grep "import.*from.*db" server/src/index.ts && echo "✓ Uses wrapper module"

# Test 5: Render simulation
npm ci && npm run build && echo "✓ Render build succeeds"
```

## Success Criteria

Your Prisma upgrade is successful when:

- [ ] Barrel file created: `src/generated/prisma/index.ts` exists
- [ ] Type check passes: `npm run typecheck` returns no errors
- [ ] Build succeeds: `npm run build` completes without errors
- [ ] Tests pass: `npm test` shows all tests passing
- [ ] Clean build passes: `rm -rf node_modules && npm ci && npm run build` works
- [ ] CI passes: All GitHub Actions jobs succeed
- [ ] Deploy succeeds: Render/Vercel deployment completes
- [ ] No runtime errors: App starts and APIs respond normally

---

## Quick Reference

### The Three-File Solution

**1. Postgenerate Script**

```bash
server/scripts/prisma-postgenerate.js  # Creates barrel file after generate
```

**2. Package.json**

```json
{
  "scripts": {
    "prisma:generate": "prisma generate && node scripts/prisma-postgenerate.js",
    "build": "npm run prisma:generate && tsc -b"
  }
}
```

**3. Wrapper Module (optional)**

```typescript
// server/src/db.ts
export * from './generated/prisma/client';
```

### The Two Risks to Test

1. **Local cache masking:** Remove `node_modules` before testing
2. **Entry point changes:** Always check Prisma release notes before upgrade

### The One Command to Remember

```bash
# Always test in clean environment, not local cache
rm -rf node_modules && npm ci && npm run build
```
