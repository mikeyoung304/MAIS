// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

// Note: In Prisma 7, database URL moved to prisma.config.ts
// The directUrl for migrations is also in prisma.config.ts
datasource db {
  provider = "postgresql"
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String?
  passwordHash String
  role         UserRole @default(USER)
  tenantId     String? // For TENANT_ADMIN users
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  tenant       Tenant?  @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
}

enum UserRole {
  USER
  ADMIN
  PLATFORM_ADMIN
  TENANT_ADMIN
}

// Multi-tenant model - each tenant is an independent wedding business
model Tenant {
  id   String @id @default(cuid())
  slug String @unique // URL-safe identifier (e.g., "bellaweddings")
  name String // Display name (e.g., "Bella Weddings")

  // Tenant Admin Authentication
  email        String? @unique // Login email for tenant admin dashboard
  passwordHash String? // Bcrypt hashed password

  // API Authentication
  apiKeyPublic String @unique // pk_live_tenant_xyz (safe for client-side)
  apiKeySecret String // Hashed secret key (admin operations only)

  // Commission Settings
  commissionPercent Decimal @default(10.0) @db.Decimal(5, 2) // Platform commission %

  // Branding Configuration for embeddable widget
  // Structure: {fontFamily, logo, etc.}
  // Example: {"fontFamily": "Inter", "logo": "https://..."}
  branding Json @default("{}") // Widget branding settings (non-color)

  // Theme Colors - Dedicated fields for runtime CSS variable updates
  // Defaults to Macon brand colors (rebuild-6.0 design system)
  primaryColor    String @default("#1a365d") // Macon Navy - main brand color (buttons, headers)
  secondaryColor  String @default("#fb923c") // Macon Orange - accent color (CTAs, highlights)
  accentColor     String @default("#38b2ac") // Macon Teal - success/positive actions
  backgroundColor String @default("#ffffff") // White - page background

  // Stripe Connect
  stripeAccountId String? @unique // Stripe Connected Account ID
  stripeOnboarded Boolean @default(false) // Has completed Stripe onboarding

  // Trial & Subscription (Product-Led Growth)
  trialEndsAt        DateTime?          // When 14-day trial expires (null = no trial started)
  subscriptionStatus SubscriptionStatus @default(NONE) // Current subscription state
  stripeCustomerId   String?            @unique // Stripe Customer ID for Checkout

  // Subscription Tier & AI Usage Limits
  tier              SubscriptionTier @default(FREE)  // Current pricing tier
  aiMessagesUsed    Int              @default(0)     // AI messages used this billing cycle
  aiMessagesResetAt DateTime?                        // When AI message counter was last reset

  // Encrypted Secrets Storage
  secrets Json @default("{}") // {stripe: {ciphertext, iv, authTag}}

  // Email verification
  emailVerified Boolean @default(false)

  // Password reset
  passwordResetToken   String?   @unique
  passwordResetExpires DateTime?

  // Status
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Deposit Settings (MVP Gaps Phase 4)
  depositPercent Decimal? @db.Decimal(5, 2) // null = full payment required
  balanceDueDays Int      @default(30)       // Days before event balance is due

  // Landing Page Configuration
  landingPageConfig      Json? // Stores tenant's landing page configuration (sections, hero, testimonials, etc.)
  landingPageConfigDraft Json? // Draft version for Build Mode editing (published via copy to landingPageConfig)

  // Tier Display Names - Tenant customization for tier labels
  // Structure: {"tier_1": "The Grounding Reset", "tier_2": "The Team Recharge", "tier_3": "The Executive Reset"}
  // Default display names (Essential/Popular/Premium) are used if not specified
  tierDisplayNames Json? @default("{}")

  // Customer Chatbot Settings
  chatEnabled Boolean @default(true) // Whether customer-facing chatbot is enabled for this tenant

  // Booking/Scheduling Settings (Phase 1 - Calendly-style scheduling)
  timezone String @default("America/New_York") // Tenant's timezone for availability calculations

  // Test Data Identification
  isTestTenant Boolean @default(false) @map("is_test_tenant") // Flag for filtering test data from admin dashboard

  // Onboarding State (Event Sourcing + XState)
  // Phase tracks current state, version enables optimistic locking, completedAt marks finish
  onboardingPhase       OnboardingPhase @default(NOT_STARTED)
  onboardingCompletedAt DateTime?       // When onboarding was finished or skipped
  onboardingVersion     Int             @default(0) // Optimistic locking version counter

  // Relations
  users            User[] // Tenant admin users
  customers        Customer[] // Tenant-scoped customers
  venues           Venue[] // Tenant-scoped venues
  segments         Segment[] // Tenant's business segments (e.g., "Wellness Retreat", "Micro-Wedding")
  packages         Package[]
  addOns           AddOn[]
  bookings         Booking[]
  payments         Payment[] // Tenant-scoped payments
  blackoutDates    BlackoutDate[]
  webhookEvents    WebhookEvent[]
  webhookSubscriptions WebhookSubscription[] // Custom webhook subscriptions (TODO-278)
  configChangeLogs ConfigChangeLog[] // Audit trail for config changes
  services         Service[] // Scheduling services (e.g., "30-Minute Consultation")
  availabilityRules AvailabilityRule[] // Scheduling availability rules
  domains          TenantDomain[] // Custom domains for tenant website
  agentProposals   AgentProposal[] // AI agent write operation proposals
  agentAuditLogs   AgentAuditLog[] // AI agent audit trail
  agentSessions    AgentSession[] // AI agent chat sessions
  onboardingEvents OnboardingEvent[] // Onboarding event sourcing audit trail
  // Agent Evaluation System relations
  conversationTraces ConversationTrace[] // Agent conversation traces
  agentUsages        AgentUsage[] // Agent token usage tracking
  userFeedbacks      UserFeedback[] // User feedback on agent responses
  reviewActions      ReviewAction[] // Human review actions on flagged traces

  @@index([slug])
  @@index([apiKeyPublic])
  @@index([isActive])
  @@index([isTestTenant]) // Filter test tenants from admin dashboard
}

// Custom Domain Model - Allows tenants to use their own domain (e.g., janephotography.com)
// DNS verification via TXT record: mais-verify=<verificationToken>
model TenantDomain {
  id                String    @id @default(cuid())
  tenantId          String    // Tenant isolation
  domain            String    @unique // e.g., "www.janephotography.com" (globally unique)
  verified          Boolean   @default(false) // Has passed DNS TXT verification
  isPrimary         Boolean   @default(false) // Is this the primary domain for the tenant
  verificationToken String    // Token for DNS TXT verification (mais-verify=<token>)
  verifiedAt        DateTime? // When verification was completed
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  tenant            Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([verified]) // Query verified domains
  @@index([tenantId, isPrimary]) // Query primary domain for tenant
}

model Customer {
  id        String    @id @default(cuid())
  tenantId  String // Tenant isolation - CRITICAL: prevents cross-tenant data leakage
  email     String? // Optional: some customers may book without email
  phone     String?
  name      String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  tenant    Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  bookings  Booking[]
  agentSessions  AgentSession[]  // Customer chat sessions
  agentProposals AgentProposal[] // Proposals created by customer chat

  @@unique([tenantId, email]) // Composite unique: email unique per tenant, not globally
  @@index([tenantId])
  @@index([email])
  @@index([createdAt]) // Query recent customers (performance optimization)
  @@index([tenantId, createdAt]) // Query recent customers by tenant (performance optimization)
}

model Venue {
  id        String    @id @default(cuid())
  tenantId  String // Tenant isolation - CRITICAL: prevents cross-tenant venue sharing
  name      String
  address   String?
  city      String?
  state     String?
  zip       String?
  capacity  Int?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  tenant    Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  bookings  Booking[]

  @@unique([tenantId, name]) // Composite unique: venue name unique per tenant
  @@index([tenantId])
  @@index([tenantId, city]) // For location-based venue queries
}

// Segment Model - Represents distinct business lines or customer routes per tenant
// Examples: "Wellness Retreat", "Micro-Wedding", "Weekend Getaway" (Little Bit Farm)
//           "Elopement", "Micro Wedding", "Full Wedding" (Traditional wedding venue)
model Segment {
  id String @id @default(cuid())
  tenantId String // Tenant isolation

  // URL and Display
  slug String // URL-safe identifier (e.g., "wellness-retreat", "micro-wedding")
  name String // Display name (e.g., "Wellness Retreats", "Intimate Weddings")

  // Landing Page Content
  heroTitle String // Hero section title (e.g., "Rejuvenate Your Mind & Body")
  heroSubtitle String? // Optional subtitle/tagline
  heroImage String? // URL to segment-specific hero image
  description String? @db.Text // Extended description for SEO and landing page

  // SEO Metadata
  metaTitle String? // Custom page title for SEO
  metaDescription String? @db.Text // Meta description for search engines

  // Display & Status
  sortOrder Int @default(0) // Order for displaying segments in navigation (lower = first)
  active Boolean @default(true) // Whether segment is publicly visible

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  packages Package[] // Packages within this segment
  addOns AddOn[] // Segment-specific add-ons
  services Service[] // Segment-specific services (for scheduling)

  // Constraints & Indexes
  @@unique([tenantId, slug]) // Each tenant has unique segment slugs
  @@index([tenantId, active]) // Query active segments for tenant
  @@index([tenantId, sortOrder]) // Query segments in display order
  @@index([tenantId])
}

model Package {
  id          String  @id @default(cuid())
  tenantId    String // Tenant isolation
  slug        String
  name        String
  description String?
  basePrice   Int
  active      Boolean @default(true)

  // Segment Relationship (nullable for backward compatibility)
  segmentId String? // Which segment this package belongs to

  // Optional Grouping within Segment (for flexible tiering)
  // Examples: "Solo", "Couple", "Group" OR "Budget", "Premium", "Luxury"
  // Leave null for flat package structure
  grouping      String? // Optional tier/group label
  groupingOrder Int?    // Order within grouping (lower = first)

  // Photo Gallery - Array of photo objects
  // Structure: [{url: string, filename: string, size: number, order: number}]
  // Max 5 photos per package, order determines display sequence
  photos Json @default("[]")

  // Draft fields for Visual Editor (null = no pending changes)
  // Tenants can edit packages in draft mode, then publish all changes at once
  draftTitle       String?
  draftDescription String?
  draftPriceCents  Int?
  draftPhotos      Json?     // Same structure as photos: [{url, filename, size, order}]
  hasDraft         Boolean   @default(false)
  draftUpdatedAt   DateTime?

  // Booking configuration - determines which booking flow to use
  // DATE: Simple date picker (weddings, events) - default
  // TIMESLOT: Time slot scheduling (consultations, appointments)
  bookingType BookingType @default(DATE)

  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  tenant    Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  segment   Segment?       @relation(fields: [segmentId], references: [id], onDelete: SetNull)
  addOns    PackageAddOn[]
  bookings  Booking[]

  @@unique([tenantId, slug]) // Each tenant has unique package slugs
  @@index([tenantId, active])
  @@index([tenantId])
  @@index([tenantId, hasDraft]) // Query packages with pending drafts
  @@index([slug])
  @@index([segmentId]) // Query packages by segment
  @@index([segmentId, grouping]) // Query packages by segment and grouping
  @@index([segmentId, active]) // Query active packages by segment (performance optimization)
}

model AddOn {
  id          String         @id @default(cuid())
  tenantId    String // Tenant isolation
  slug        String
  name        String
  description String?
  price       Int
  active      Boolean        @default(true)

  // Segment Scoping (nullable - null = available to all segments)
  segmentId String? // If set, add-on only available for packages in this segment

  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  tenant      Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  segment     Segment?       @relation(fields: [segmentId], references: [id], onDelete: SetNull)
  packages    PackageAddOn[]
  bookingRefs BookingAddOn[]

  @@unique([tenantId, slug]) // Each tenant has unique add-on slugs
  @@index([tenantId, active])
  @@index([tenantId])
  @@index([tenantId, segmentId]) // Query add-ons by tenant and segment (null = global)
}

model PackageAddOn {
  packageId String
  addOnId   String
  package   Package @relation(fields: [packageId], references: [id], onDelete: Cascade)
  addOn     AddOn   @relation(fields: [addOnId], references: [id], onDelete: Cascade)

  @@id([packageId, addOnId])
  @@index([packageId])
  @@index([addOnId])
}

model Booking {
  id         String        @id @default(cuid())
  tenantId   String // Tenant isolation
  customerId String
  packageId  String? // Optional for TIMESLOT bookings (which use serviceId instead)
  venueId    String?

  // Customer-facing confirmation code for booking lookups (e.g., "BK-ABC123")
  confirmationCode String? @unique

  // Scheduling fields - supports both date-only (legacy) and time-slot bookings
  date       DateTime      @db.Date
  startTime  DateTime?     // UTC - for time-slot bookings
  endTime    DateTime?     // UTC - for time-slot bookings

  // Booking type: DATE for legacy wedding bookings, TIMESLOT for scheduling
  bookingType BookingType @default(DATE)

  // Service reference (for time-slot bookings)
  serviceId  String?

  // Client timezone for display purposes (e.g., "America/New_York")
  clientTimezone String?

  status     BookingStatus @default(PENDING)
  totalPrice Int
  notes      String?

  // Payment tracking - when full payment was completed
  paidAt     DateTime?

  // Platform Commission (multi-tenant)
  commissionAmount  Int     @default(0) // In cents (platform fee)
  commissionPercent Decimal @default(0) @db.Decimal(5, 2) // Snapshot of rate at booking time

  // Stripe Payment
  stripePaymentIntentId String? @unique // Stripe PaymentIntent ID

  // Google Calendar sync
  googleEventId String? // Google Calendar event ID for sync

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  confirmedAt DateTime? // When payment completed
  cancelledAt DateTime? // When cancelled

  // Cancellation tracking (MVP Gaps Phase 1)
  cancelledBy        CancelledBy?  // Who cancelled the booking
  cancellationReason String?       // Reason for cancellation

  // Refund tracking (MVP Gaps Phase 1)
  refundStatus    RefundStatus @default(NONE)
  refundAmount    Int?         // Amount refunded in cents
  refundedAt      DateTime?    // When refund was processed
  stripeRefundId  String?      // Stripe refund ID

  // Reminder tracking (MVP Gaps Phase 2)
  reminderSentAt  DateTime?    // When reminder email was sent
  reminderDueDate DateTime?    // When reminder should be sent (eventDate - 7 days)

  // Deposit tracking (MVP Gaps Phase 4)
  depositPaidAmount Int?       // Amount paid as deposit in cents
  balanceDueDate    DateTime?  // When balance payment is due
  balancePaidAmount Int?       // Balance amount paid in cents
  balancePaidAt     DateTime?  // When balance was paid

  tenant   Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer Customer       @relation(fields: [customerId], references: [id])
  package  Package?       @relation(fields: [packageId], references: [id])
  venue    Venue?         @relation(fields: [venueId], references: [id])
  service  Service?       @relation(fields: [serviceId], references: [id])
  addOns   BookingAddOn[]
  payments Payment[]

  // Unique constraints:
  // - For DATE bookings: one per tenant per date (legacy behavior)
  // - For TIMESLOT bookings: partial unique index via migration (see migrations/20251128000000_add_timeslot_unique_constraint)
  //   PostgreSQL partial unique index: (tenantId, serviceId, startTime) WHERE startTime IS NOT NULL
  @@unique([tenantId, date, bookingType]) // Composite unique for date-only bookings
  @@index([tenantId, status])
  @@index([tenantId, date])
  @@index([tenantId, date, bookingType]) // DATE booking availability queries (TODO-327)
  @@index([tenantId, startTime]) // For time-slot queries
  @@index([tenantId, status, date])
  @@index([tenantId])
  @@index([customerId])
  @@index([packageId])
  @@index([serviceId])
  @@index([venueId])
  @@index([stripePaymentIntentId])
  @@index([googleEventId])
  @@index([createdAt])
  @@index([tenantId, confirmedAt])
  @@index([tenantId, reminderDueDate, reminderSentAt, status]) // For reminder queries (TODO-153)
  // Note: Partial index for reminder queries exists via manual migration 08
  // CREATE INDEX idx_booking_reminder_due ON Booking (tenantId, reminderDueDate)
  // WHERE reminderSentAt IS NULL AND status = 'CONFIRMED'

  // Performance indexes (TODO-275) - applied via manual migration 10
  @@index([tenantId, bookingType, startTime, endTime]) // Timeslot availability queries
  @@index([tenantId, serviceId, startTime]) // Service-specific queries
  @@index([tenantId, bookingType, startTime, status]) // Appointment pagination
  @@index([tenantId, createdAt, status]) // Revenue queries (TODO-456) - agent dashboard/refresh_context
}

enum BookingStatus {
  PENDING       // Initial state, awaiting payment
  DEPOSIT_PAID  // Deposit received, balance due later
  PAID          // Full payment received (deposit + balance or full upfront)
  CONFIRMED     // Payment confirmed, booking finalized
  CANCELED      // Booking cancelled
  REFUNDED      // Full refund processed
  FULFILLED     // Event completed
}

/// Determines the booking flow and availability constraints for a package
enum BookingType {
  /// Date-only bookings: Customer selects a single day (e.g., wedding on June 15)
  /// - Enforces one booking per tenant per date via unique constraint
  /// - Used by: wedding venues, event spaces, full-day rentals
  /// - Flow: TierDetail → DateBookingWizard → Stripe checkout
  DATE

  /// Time-slot bookings: Customer selects specific time slots (e.g., 2:00pm-3:00pm)
  /// - Multiple bookings allowed per day with different time slots
  /// - Used by: consultations, appointments, hourly services
  /// - Flow: ServiceSelection → TimeSlotPicker → Stripe checkout
  TIMESLOT
}

// MVP Gaps Phase 1: Cancellation tracking
enum CancelledBy {
  CUSTOMER  // Customer self-service cancellation
  TENANT    // Tenant admin cancelled
  ADMIN     // Platform admin cancelled
  SYSTEM    // Automated system cancellation
}

// MVP Gaps Phase 1: Refund tracking
enum RefundStatus {
  NONE       // No refund requested
  PENDING    // Refund requested, not yet processed
  PROCESSING // Refund in progress
  COMPLETED  // Refund successfully completed
  PARTIAL    // Partial refund completed
  FAILED     // Refund failed
}

// ============================================================================
// Scheduling Models (MVP - Single Provider)
// ============================================================================

// Service Model - Represents bookable services/appointment types
model Service {
  id               String   @id @default(cuid())
  tenantId         String   // Tenant isolation
  slug             String   // URL-safe identifier (e.g., "consultation", "haircut")
  name             String   // Display name (e.g., "30-Minute Consultation")
  description      String?  @db.Text
  durationMinutes  Int      // Service duration (e.g., 30, 60, 90)
  bufferMinutes    Int      @default(0) // Buffer time after service
  priceCents       Int      // Service price in cents
  timezone         String   @default("America/New_York") // Tenant's timezone for availability
  active           Boolean  @default(true)
  sortOrder        Int      @default(0)

  // Booking Link Settings (Phase 1 - Calendly-style scheduling)
  minNoticeMinutes Int      @default(120)  // Minimum advance notice required (default 2 hours)
  maxAdvanceDays   Int      @default(60)   // How far in advance bookings can be made (default 60 days)
  maxPerDay        Int?                    // Maximum bookings per day (null = unlimited)

  // Optional segment association
  segmentId        String?

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  tenant           Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  segment          Segment? @relation(fields: [segmentId], references: [id], onDelete: SetNull)
  availabilityRules AvailabilityRule[]
  bookings         Booking[]

  @@unique([tenantId, slug])
  @@index([tenantId, active])
  @@index([tenantId])
  @@index([segmentId])
}

// AvailabilityRule Model - Defines when services are available
model AvailabilityRule {
  id            String    @id @default(cuid())
  tenantId      String    // Tenant isolation
  serviceId     String?   // NULL = applies to all services (default availability)
  dayOfWeek     Int       // 0=Sunday, 1=Monday, ..., 6=Saturday
  startTime     String    // "09:00" (in tenant timezone)
  endTime       String    // "17:00" (in tenant timezone)
  effectiveFrom DateTime  @default(now())
  effectiveTo   DateTime? // NULL = indefinite

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  tenant        Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  service       Service?  @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@unique([tenantId, serviceId, dayOfWeek, startTime])
  @@index([tenantId, dayOfWeek])
  @@index([serviceId])
}

model BookingAddOn {
  bookingId String
  addOnId   String
  quantity  Int     @default(1)
  unitPrice Int
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  addOn     AddOn   @relation(fields: [addOnId], references: [id], onDelete: Restrict)

  @@id([bookingId, addOnId])
  @@index([bookingId])
  @@index([addOnId])
}

model Payment {
  id          String        @id @default(cuid())
  tenantId    String
  bookingId   String
  amount      Int
  currency    String        @default("USD")
  status      PaymentStatus @default(PENDING)
  processor   String
  processorId String?
  createdAt   DateTime      @default(now())

  tenant      Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  booking     Booking       @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@unique([tenantId, processorId])
  @@index([tenantId])
  @@index([tenantId, status])
  @@index([tenantId, createdAt])
  @@index([bookingId])
  @@index([processorId])
}

enum PaymentStatus {
  PENDING
  AUTHORIZED
  CAPTURED
  CANCELED
  FAILED
}

/// Subscription status for tenant billing
enum SubscriptionStatus {
  NONE      // Signed up, no trial started
  TRIALING  // In 14-day trial
  ACTIVE    // Paid customer
  EXPIRED   // Trial ended, didn't pay (soft lock)
}

/// Subscription tier for pricing/limits
enum SubscriptionTier {
  FREE      // Trial tier (14 days, 50 AI messages)
  STARTER   // $49/month (500 AI messages)
  PRO       // $150/month (5000 AI messages)
}

model BlackoutDate {
  id        String   @id @default(cuid())
  tenantId  String // Tenant isolation
  date      DateTime @db.Date
  reason    String?
  createdAt DateTime @default(now())
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, date]) // Each tenant manages their own blackout dates
  @@index([tenantId, date])
  @@index([tenantId])
}

model WebhookEvent {
  id          String        @id @default(uuid())
  tenantId    String // Tenant isolation
  eventId     String // Stripe event ID - NOT globally unique (different tenants can have same event ID)
  eventType   String
  rawPayload  String        @db.Text
  status      WebhookStatus @default(PENDING)
  attempts    Int           @default(1)
  lastError   String?       @db.Text
  processedAt DateTime?
  createdAt   DateTime      @default(now())
  tenant      Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, eventId], name: "tenantId_eventId") // Composite unique: CRITICAL for preventing cross-tenant event hijacking
  @@index([tenantId, status]) // Query webhooks by tenant and status
  @@index([tenantId, createdAt]) // Query webhooks by tenant chronologically
  @@index([tenantId])
  @@index([eventId]) // Global lookup for debugging
  @@index([status])
  @@index([status, createdAt])
}

enum WebhookStatus {
  PENDING
  PROCESSED
  FAILED
  DUPLICATE
}

// ============================================================================
// Early Access Requests (Waitlist)
// ============================================================================

// Platform-level table (not tenant-scoped) for tracking early access requests
// before users become tenants
model EarlyAccessRequest {
  id        String   @id @default(cuid())
  email     String   @unique // Prevent duplicate submissions
  status    String   @default("pending") // pending, contacted, converted, unsubscribed
  source    String?  // Where they signed up from (e.g., "homepage", "blog", "referral")
  notes     String?  @db.Text // Admin notes for follow-up
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status]) // Query by status
  @@index([createdAt]) // Query chronologically
}

// Audit Log for Config-Driven System (Sprint 2.1)
// Tracks all configuration changes and legacy CRUD during migration
model ConfigChangeLog {
  id       String @id @default(cuid())
  tenantId String // Tenant isolation

  // Change metadata
  changeType String // 'config_version', 'agent_proposal', 'package_crud', 'branding_update', 'blackout_change'
  operation  String // 'create', 'update', 'delete', 'publish', 'approve', 'reject'
  entityType String // 'ConfigVersion', 'AgentProposal', 'Package', 'Tenant', 'BlackoutDate'
  entityId   String // ID of the entity being changed

  // Attribution (who made the change)
  userId  String? // For admin actions
  agentId String? // For agent actions (future)
  email   String // User or agent email
  role    String // 'PLATFORM_ADMIN', 'TENANT_ADMIN', 'AGENT'

  // Change data (full snapshots for rollback)
  beforeSnapshot Json? // State before change (null for creates)
  afterSnapshot  Json // State after change

  // Metadata
  reason   String? // Optional reason for change
  metadata Json? // Additional context (IP address, user agent, session ID, etc.)

  // Timestamps (PostgreSQL DateTime has microsecond precision)
  createdAt DateTime @default(now())

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Indexes for fast queries
  @@index([tenantId, createdAt]) // Audit log timeline for tenant
  @@index([tenantId, entityType, entityId]) // All changes to specific entity
  @@index([tenantId, changeType]) // Filter by change type
  @@index([userId]) // Track changes by user
  @@index([tenantId, userId]) // Track user changes per tenant
  @@index([entityType, entityId]) // Global entity change lookup
}

// Idempotency Key Tracking (Stripe Operations)
// Prevents duplicate charges, refunds, and transfers via unique key storage
model IdempotencyKey {
  id        String   @id @default(cuid())
  key       String   @unique // Unique idempotency key (e.g., "checkout_a3b2c1d4...")
  response  String?  @db.Text // Cached JSON response for duplicate requests
  createdAt DateTime @default(now())
  expiresAt DateTime // Automatic expiration (24 hours from creation)

  @@index([expiresAt]) // For efficient cleanup of expired keys
}

// ============================================================================
// Custom Webhook Subscriptions (Acuity Parity - TODO-278)
// ============================================================================

// WebhookSubscription - Tenant-configured webhook endpoints for outbound events
// Allows tenants to receive real-time notifications for appointment lifecycle events
model WebhookSubscription {
  id        String   @id @default(cuid())
  tenantId  String   // Tenant isolation
  url       String   // Webhook endpoint URL
  events    String[] // Event types to subscribe to (e.g., ['appointment.created', 'appointment.canceled'])
  secret    String   // HMAC signing secret for payload verification
  active    Boolean  @default(true) // Whether subscription is enabled
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant     Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  deliveries WebhookDelivery[]

  @@unique([tenantId, url]) // One subscription per URL per tenant
  @@index([tenantId, active]) // Query active subscriptions
  @@index([tenantId])
}

// WebhookDelivery - Outbound webhook delivery tracking and retry logic
model WebhookDelivery {
  id             String   @id @default(cuid())
  subscriptionId String   // Which subscription this delivery belongs to
  event          String   // Event type (e.g., 'appointment.created')
  payload        Json     // Event payload to deliver
  status         String   @default("pending") // 'pending', 'delivered', 'failed'
  attempts       Int      @default(0) // Number of delivery attempts
  lastAttemptAt  DateTime? // When last delivery attempt was made
  deliveredAt    DateTime? // When successfully delivered
  lastError      String?   @db.Text // Last error message if delivery failed
  createdAt      DateTime @default(now())

  subscription   WebhookSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId, status]) // Query pending/failed deliveries
  @@index([status, createdAt]) // Query deliveries by status chronologically
  @@index([subscriptionId])
}

// ============================================================================
// AI Agent Integration Models
// ============================================================================

/// AgentProposal - Server-side storage for agent write operation proposals
/// Implements trust tier enforcement:
/// - T1 operations: Auto-confirmed, proposal created and immediately executed
/// - T2 operations: Proposal created, auto-confirms after next user message (unless "wait")
/// - T3 operations: Proposal created, requires explicit confirm_proposal() call
///
/// Security: Prevents prompt injection from bypassing approval - server enforces it
model AgentProposal {
  id              String             @id @default(cuid())
  tenantId        String             // Tenant isolation - CRITICAL
  sessionId       String             // Agent session identifier
  customerId      String?            // CRITICAL: For customer proposals - enables ownership verification
  toolName        String             // Tool that created the proposal (e.g., "upsert_package")
  operation       String             // Human-readable operation description
  trustTier       AgentTrustTier     // T1, T2, or T3
  payload         Json               // The proposed change data
  preview         Json               // What will change (for user display)
  status          AgentProposalStatus @default(PENDING)
  requiresApproval Boolean           @default(true)
  expiresAt       DateTime           // 30 minutes from creation
  confirmedAt     DateTime?          // When user confirmed
  executedAt      DateTime?          // When proposal was executed
  result          Json?              // Execution result (for completed proposals)
  error           String?            // Error message if failed
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt

  tenant          Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer        Customer?          @relation(fields: [customerId], references: [id], onDelete: SetNull)

  @@index([tenantId, sessionId])
  @@index([tenantId, status])
  @@index([expiresAt]) // For cleanup of expired proposals
  @@index([status, expiresAt]) // P1 fix: Cleanup job queries (status + expiresAt)
  @@index([status, updatedAt]) // P3-616: Orphan proposal recovery query
  @@index([tenantId])
  @@index([customerId]) // Query proposals by customer
}

enum AgentTrustTier {
  T1  // No confirm needed - blackouts, branding, visibility toggles
  T2  // Soft confirm - package changes, landing page updates, pricing
  T3  // Hard confirm - cancellations, refunds, deletes with existing bookings
}

enum AgentProposalStatus {
  PENDING    // Awaiting confirmation
  CONFIRMED  // User confirmed, ready to execute
  EXECUTED   // Successfully executed
  EXPIRED    // TTL exceeded (30 minutes)
  REJECTED   // User said "wait" or "no"
  FAILED     // Execution failed
}

/// AgentAuditLog - Audit trail for all agent tool calls
/// Required for security compliance: 90 days minimum, 7 years for financial operations
model AgentAuditLog {
  id              String             @id @default(cuid())
  tenantId        String             // Tenant isolation - CRITICAL
  sessionId       String             // Agent session identifier
  toolName        String             // Tool that was called
  proposalId      String?            // Reference to proposal (if write operation)
  inputSummary    String             @db.VarChar(500) // Sanitized input summary
  outputSummary   String             @db.VarChar(500) // Sanitized output summary
  trustTier       AgentTrustTier
  approvalStatus  AgentApprovalStatus
  durationMs      Int?               // Execution duration in milliseconds
  success         Boolean            @default(true)
  errorMessage    String?            @db.Text
  createdAt       DateTime           @default(now())

  tenant          Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, sessionId])
  @@index([tenantId, createdAt])
  @@index([tenantId, toolName])
  @@index([createdAt]) // For retention cleanup
  @@index([tenantId])
}

enum AgentApprovalStatus {
  AUTO      // T1 - auto-approved
  SOFT      // T2 - soft confirm (proceeds after next message)
  EXPLICIT  // T3 - explicit user confirmation received
  BYPASSED  // Security bypass attempt (should never happen, logged for audit)
}

/// AgentSession - Conversation session for AI agent chat
/// Stores message history and session state for continuity
/// Supports both admin (tenant owner) and customer-facing sessions
model AgentSession {
  id          String      @id @default(cuid())
  tenantId    String      // Tenant isolation - CRITICAL
  customerId  String?     // NULL for admin sessions, set for customer sessions
  sessionType SessionType @default(ADMIN) // ADMIN or CUSTOMER
  messages    Json        @default("[]") // Array of ChatMessage objects
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  tenant      Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer    Customer?   @relation(fields: [customerId], references: [id], onDelete: SetNull)

  @@index([tenantId, updatedAt]) // Find recent sessions for tenant
  @@index([tenantId])
  @@index([customerId, updatedAt]) // Query customer sessions
  @@index([sessionType, updatedAt]) // Cleanup job queries
  @@index([tenantId, sessionType, updatedAt]) // #530: getOrCreateSession queries all 3 fields
}

/// Session type for agent conversations
enum SessionType {
  ADMIN    // Tenant owner/admin using the business growth agent
  CUSTOMER // Customer using the public booking chatbot
}

// ============================================================================
// Onboarding Agent Models (Event Sourcing)
// ============================================================================

/// OnboardingEvent - Event sourcing model for onboarding agent
/// Provides audit trail and state reconstruction for tenant onboarding flow.
/// Each event represents a state transition or data collection milestone.
///
/// Event Types:
/// - DISCOVERY_STARTED: Initial onboarding session started
/// - DISCOVERY_COMPLETED: Business type, location, target market collected
/// - MARKET_RESEARCH_STARTED: Market research phase initiated
/// - MARKET_RESEARCH_COMPLETED: Pricing benchmarks and competitor data collected
/// - SERVICES_CONFIGURED: Service packages created/updated
/// - MARKETING_CONFIGURED: Landing page and brand voice configured
/// - ONBOARDING_COMPLETED: Full onboarding flow completed
/// - ONBOARDING_SKIPPED: User chose to skip onboarding
model OnboardingEvent {
  id        String   @id @default(cuid())
  tenantId  String   // Tenant isolation - CRITICAL
  eventType String   // Discriminated event type (e.g., "discovery_completed")
  payload   Json     // Event-specific payload (validated by Zod)
  timestamp DateTime @default(now())
  version   Int      // Sequential version for optimistic locking

  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, timestamp])
  @@index([tenantId, version])
}

/// Onboarding phase enum for state machine
enum OnboardingPhase {
  NOT_STARTED      // Initial state - no onboarding interaction yet
  DISCOVERY        // Collecting business info (type, location, target market)
  MARKET_RESEARCH  // Analyzing market and generating pricing recommendations
  SERVICES         // Creating service packages based on recommendations
  MARKETING        // Configuring landing page and brand voice
  COMPLETED        // Onboarding finished
  SKIPPED          // User opted to skip onboarding
}

// ============================================================================
// Agent Evaluation System Models (Phase 1: Observability Foundation)
// ============================================================================

/// ConversationTrace - Complete conversation trace for agent evaluation
/// Stores full message history, tool calls, and evaluation results.
///
/// Security:
/// - messages and toolCalls contain PII and are encrypted via Prisma middleware
/// - All queries MUST be tenant-scoped
///
/// Retention:
/// - 90-day default retention via expiresAt column
/// - Cleanup job removes expired traces
model ConversationTrace {
  id                 String    @id @default(cuid())
  tenantId           String    // Tenant isolation - CRITICAL
  sessionId          String    // Agent session identifier
  agentType          String    // 'customer' | 'onboarding' | 'admin'

  // Timing
  startedAt          DateTime
  endedAt            DateTime?

  // Metrics
  turnCount          Int       @default(0)
  totalTokens        Int       @default(0)
  inputTokens        Int       @default(0)
  outputTokens       Int       @default(0)
  totalLatencyMs     Int       @default(0)
  estimatedCostCents Int       @default(0)

  // Content (JSON) - ENCRYPTED via Prisma middleware (contains PII)
  messages           Json      // TracedMessage[] - encrypted
  toolCalls          Json      // TracedToolCall[] - encrypted
  errors             Json?     // Error objects

  // Retention (90-day default)
  expiresAt          DateTime? // Auto-cleanup after this date

  // Context
  promptVersion      String?   // For A/B tracking
  cacheHit           Boolean   @default(false)

  // Outcome
  taskCompleted      Boolean?
  userSatisfaction   Int?      // 1-5 rating

  // Evaluation
  evalScore          Float?    // 0-10 overall score
  evalDimensions     Json?     // { effectiveness, experience, safety }
  evalReasoning      String?   @db.Text // LLM's explanation
  evalConfidence     Float?    // 0-1
  evaluatedAt        DateTime?

  // Review
  flagged            Boolean   @default(false)
  flagReason         String?
  reviewStatus       String?   // 'pending' | 'reviewed' | 'actioned'
  reviewedAt         DateTime?
  reviewedBy         String?
  reviewNotes        String?   @db.Text

  // Relations
  tenant             Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  reviewActions      ReviewAction[]
  feedbacks          UserFeedback[]

  // CRITICAL: Tenant-scoped indexes only
  @@index([tenantId, startedAt])
  @@index([tenantId, agentType, startedAt])
  @@index([tenantId, flagged, reviewStatus])
  @@index([tenantId, evalScore])
  @@index([tenantId, evalScore, startedAt]) // P1-582: getUnevaluatedTraces query optimization
  @@index([sessionId])
  @@index([expiresAt]) // For cleanup job
}

/// AgentUsage - Token usage and cost tracking per agent call
/// Used for cost monitoring, budget alerts, and billing
model AgentUsage {
  id            String   @id @default(cuid())
  tenantId      String   // Tenant isolation - CRITICAL
  agentType     String   // 'customer' | 'onboarding' | 'admin'
  model         String   // LLM model used (e.g., 'claude-sonnet-4-20250514')
  inputTokens   Int
  outputTokens  Int
  cost          Float    // Cost in dollars
  timestamp     DateTime @default(now())

  tenant        Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, timestamp])
  @@index([tenantId, agentType, timestamp])
}

/// UserFeedback - Explicit user feedback on agent responses
/// Collected via thumbs up/down or 1-5 star rating
model UserFeedback {
  id            String   @id @default(cuid())
  tenantId      String   // Tenant isolation - CRITICAL
  sessionId     String
  traceId       String?  // Reference to ConversationTrace
  rating        Int      // 1-5 star rating
  comment       String?  @db.Text
  messageId     String?  // Specific message being rated
  deviceType    String?  // 'mobile' | 'desktop'
  createdAt     DateTime @default(now())

  tenant        Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  trace         ConversationTrace? @relation(fields: [traceId], references: [id], onDelete: SetNull)

  @@index([tenantId, sessionId])
  @@index([tenantId, createdAt])
  @@index([traceId])
  @@index([traceId, createdAt]) // For orphan feedback cleanup query
}

/// ReviewAction - Human review actions on flagged conversations
/// Tracks what action was taken on each reviewed trace
model ReviewAction {
  id              String   @id @default(cuid())
  tenantId        String   // Tenant isolation - CRITICAL
  traceId         String
  action          String   // 'approve' | 'reject' | 'escalate' | 'retrain' | 'prompt_updated' | 'bug_filed'
  notes           String?  @db.Text
  correctedScore  Float?   // If reviewer disagrees with LLM eval
  performedBy     String   // userId or 'system'
  performedAt     DateTime @default(now())

  trace           ConversationTrace @relation(fields: [traceId], references: [id], onDelete: Cascade)
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, performedAt])
  @@index([traceId])
  @@index([tenantId, action])
}
