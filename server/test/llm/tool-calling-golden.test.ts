/**
 * Tool Calling Golden Tests
 *
 * Unit tests verifying the message-adapter functions correctly handle
 * Gemini's tool calling semantics. These are "golden" tests that document
 * expected behavior as a contract.
 *
 * Key Vertex AI semantics tested:
 * 1. Model emits functionCall in response parts
 * 2. Function responses use 'user' role (NOT a dedicated 'tool' role)
 * 3. Multiple parallel tool calls get batch responses
 * 4. Each tool call gets a unique ID (generated by us, not Gemini)
 *
 * @see https://docs.cloud.google.com/vertex-ai/generative-ai/docs/multimodal/function-calling
 */

import { describe, it, expect, vi } from 'vitest';
import {
  toGeminiFunctionDeclarations,
  toGeminiFunctionResponse,
  toGeminiMultipleFunctionResponses,
  toGeminiContents,
  toSystemInstruction,
  extractToolCalls,
  extractText,
  hasToolCalls,
  extractModelContent,
  extractUsage,
  type ChatMessage,
  type ToolCall,
} from '../../src/llm/message-adapter';
import type { AgentTool, AgentToolResult } from '../../src/agent/tools/types';
import type { GenerateContentResponse } from '@google/genai';

// ─────────────────────────────────────────────────────────────────────────────
// Fixture: Mock Gemini Responses
// ─────────────────────────────────────────────────────────────────────────────

function createMockResponse(
  parts: Array<{ text?: string; functionCall?: { name: string; args: unknown } }>
): GenerateContentResponse {
  return {
    candidates: [
      {
        content: {
          role: 'model',
          parts,
        },
      },
    ],
    usageMetadata: {
      promptTokenCount: 100,
      candidatesTokenCount: 50,
      totalTokenCount: 150,
    },
  } as GenerateContentResponse;
}

// ─────────────────────────────────────────────────────────────────────────────
// Test Suite: Model Emits Function Calls
// ─────────────────────────────────────────────────────────────────────────────

describe('1. Model emits function call', () => {
  it('should parse single functionCall from model response', () => {
    const mockResponse = createMockResponse([
      {
        functionCall: {
          name: 'get_weather',
          args: { location: 'San Francisco' },
        },
      },
    ]);

    const toolCalls = extractToolCalls(mockResponse);

    expect(toolCalls).toHaveLength(1);
    expect(toolCalls[0].name).toBe('get_weather');
    expect(toolCalls[0].input).toEqual({ location: 'San Francisco' });
    expect(toolCalls[0].id).toBeDefined();
    expect(typeof toolCalls[0].id).toBe('string');
    expect(toolCalls[0].id.length).toBeGreaterThan(0);
  });

  it('should handle text before function call', () => {
    const mockResponse = createMockResponse([
      { text: 'Let me check the weather for you.' },
      {
        functionCall: {
          name: 'get_weather',
          args: { location: 'NYC' },
        },
      },
    ]);

    const text = extractText(mockResponse);
    const toolCalls = extractToolCalls(mockResponse);

    expect(text).toBe('Let me check the weather for you.');
    expect(toolCalls).toHaveLength(1);
    expect(toolCalls[0].name).toBe('get_weather');
  });

  it('should handle empty args gracefully', () => {
    const mockResponse = createMockResponse([
      {
        functionCall: {
          name: 'get_services',
          args: {},
        },
      },
    ]);

    const toolCalls = extractToolCalls(mockResponse);

    expect(toolCalls).toHaveLength(1);
    expect(toolCalls[0].input).toEqual({});
  });

  it('should handle null/undefined args', () => {
    const mockResponse = createMockResponse([
      {
        functionCall: {
          name: 'get_services',
          args: null as unknown as Record<string, unknown>,
        },
      },
    ]);

    const toolCalls = extractToolCalls(mockResponse);

    expect(toolCalls).toHaveLength(1);
    expect(toolCalls[0].input).toEqual({});
  });
});

// ─────────────────────────────────────────────────────────────────────────────
// Test Suite: Function Response Formatting (Critical Contract)
// ─────────────────────────────────────────────────────────────────────────────

describe('2. Tool execution result formatting', () => {
  it('should format successful result with user role (Vertex AI semantics)', () => {
    const toolCall: ToolCall = { id: 'test-id-123', name: 'get_weather', input: {} };
    const result: AgentToolResult = { success: true, data: { temperature: 72 } };

    const content = toGeminiFunctionResponse(toolCall, result);

    // CRITICAL: Vertex AI uses 'user' role for function responses
    expect(content.role).toBe('user');
    expect(content.parts).toHaveLength(1);
    expect(content.parts[0]).toHaveProperty('functionResponse');
    expect(content.parts[0].functionResponse).toEqual({
      name: 'get_weather',
      response: { result: { temperature: 72 } },
    });
  });

  it('should format error result correctly', () => {
    const toolCall: ToolCall = { id: 'test-id-456', name: 'get_weather', input: {} };
    const result: AgentToolResult = { success: false, error: 'Location not found' };

    const content = toGeminiFunctionResponse(toolCall, result);

    expect(content.role).toBe('user');
    expect(content.parts[0].functionResponse).toEqual({
      name: 'get_weather',
      response: { error: 'Location not found' },
    });
  });

  it('should handle null data in successful result', () => {
    const toolCall: ToolCall = { id: 'test-id', name: 'delete_item', input: {} };
    const result: AgentToolResult = { success: true, data: null };

    const content = toGeminiFunctionResponse(toolCall, result);

    expect(content.parts[0].functionResponse).toEqual({
      name: 'delete_item',
      response: { result: null },
    });
  });

  it('should handle complex nested data', () => {
    const toolCall: ToolCall = { id: 'test-id', name: 'get_services', input: {} };
    const result: AgentToolResult = {
      success: true,
      data: {
        services: [
          { id: '1', name: 'Basic', price: 100 },
          { id: '2', name: 'Premium', price: 200 },
        ],
        totalCount: 2,
      },
    };

    const content = toGeminiFunctionResponse(toolCall, result);

    expect(content.parts[0].functionResponse?.response).toEqual({
      result: {
        services: [
          { id: '1', name: 'Basic', price: 100 },
          { id: '2', name: 'Premium', price: 200 },
        ],
        totalCount: 2,
      },
    });
  });
});

// ─────────────────────────────────────────────────────────────────────────────
// Test Suite: Parallel Tool Calls
// ─────────────────────────────────────────────────────────────────────────────

describe('3. Parallel tool calls handling', () => {
  it('should parse multiple functionCall parts', () => {
    const mockResponse = createMockResponse([
      { functionCall: { name: 'get_weather', args: { location: 'SF' } } },
      { functionCall: { name: 'get_weather', args: { location: 'NYC' } } },
    ]);

    const toolCalls = extractToolCalls(mockResponse);

    expect(toolCalls).toHaveLength(2);
    expect(toolCalls[0].name).toBe('get_weather');
    expect(toolCalls[0].input).toEqual({ location: 'SF' });
    expect(toolCalls[1].name).toBe('get_weather');
    expect(toolCalls[1].input).toEqual({ location: 'NYC' });
  });

  it('should format multiple tool results in single user message', () => {
    const toolResults = [
      {
        toolCall: { id: 'id-1', name: 'get_weather', input: { location: 'SF' } },
        result: { success: true, data: { temp: 65 } } as AgentToolResult,
      },
      {
        toolCall: { id: 'id-2', name: 'get_weather', input: { location: 'NYC' } },
        result: { success: true, data: { temp: 45 } } as AgentToolResult,
      },
    ];

    const content = toGeminiMultipleFunctionResponses(toolResults);

    expect(content.role).toBe('user');
    expect(content.parts).toHaveLength(2);
    expect(content.parts[0].functionResponse?.name).toBe('get_weather');
    expect(content.parts[1].functionResponse?.name).toBe('get_weather');
  });
});

// ─────────────────────────────────────────────────────────────────────────────
// Test Suite: ID Generation and Idempotency
// ─────────────────────────────────────────────────────────────────────────────

describe('4. Idempotency - unique tool call IDs', () => {
  it('should generate unique IDs for each tool call', () => {
    const mockResponse = createMockResponse([
      { functionCall: { name: 'tool_a', args: {} } },
      { functionCall: { name: 'tool_b', args: {} } },
    ]);

    const toolCalls = extractToolCalls(mockResponse);

    expect(toolCalls[0].id).not.toBe(toolCalls[1].id);
  });

  it('should generate different IDs on subsequent extractions', () => {
    const mockResponse = createMockResponse([{ functionCall: { name: 'get_services', args: {} } }]);

    const firstCalls = extractToolCalls(mockResponse);
    const secondCalls = extractToolCalls(mockResponse);

    // Each extraction generates new IDs (UUID-based)
    expect(firstCalls[0].id).not.toBe(secondCalls[0].id);
  });

  it('should generate valid UUID format', () => {
    const mockResponse = createMockResponse([{ functionCall: { name: 'test', args: {} } }]);

    const toolCalls = extractToolCalls(mockResponse);
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

    expect(toolCalls[0].id).toMatch(uuidRegex);
  });
});

// ─────────────────────────────────────────────────────────────────────────────
// Test Suite: Function Declaration Conversion
// ─────────────────────────────────────────────────────────────────────────────

describe('5. Function declaration conversion', () => {
  it('should convert AgentTool to FunctionDeclaration', () => {
    const tools: AgentTool[] = [
      {
        name: 'check_availability',
        description: 'Check availability for a date',
        trustTier: 'T1',
        inputSchema: {
          type: 'object',
          properties: {
            date: { type: 'string', description: 'ISO date' },
            packageId: { type: 'string' },
          },
          required: ['date'],
        },
        execute: vi.fn(),
      },
    ];

    const declarations = toGeminiFunctionDeclarations(tools);

    expect(declarations).toHaveLength(1);
    expect(declarations[0].name).toBe('check_availability');
    expect(declarations[0].description).toBe('Check availability for a date');
    expect(declarations[0].parameters).toBeDefined();
    expect(declarations[0].parameters?.type).toBe('OBJECT');
    expect(declarations[0].parameters?.properties).toHaveProperty('date');
    expect(declarations[0].parameters?.required).toEqual(['date']);
  });

  it('should convert nested object schemas', () => {
    const tools: AgentTool[] = [
      {
        name: 'create_booking',
        description: 'Create a booking',
        trustTier: 'T2',
        inputSchema: {
          type: 'object',
          properties: {
            customer: {
              type: 'object',
              properties: {
                name: { type: 'string' },
                email: { type: 'string' },
              },
              required: ['name', 'email'],
            },
            date: { type: 'string' },
          },
          required: ['customer', 'date'],
        },
        execute: vi.fn(),
      },
    ];

    const declarations = toGeminiFunctionDeclarations(tools);
    const customerProp = declarations[0].parameters?.properties?.customer;

    expect(customerProp).toBeDefined();
    expect(customerProp?.type).toBe('OBJECT');
    expect(customerProp?.properties).toHaveProperty('name');
    expect(customerProp?.properties).toHaveProperty('email');
  });

  it('should convert array schemas', () => {
    const tools: AgentTool[] = [
      {
        name: 'upsert_services',
        description: 'Create/update services',
        trustTier: 'T2',
        inputSchema: {
          type: 'object',
          properties: {
            segments: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  name: { type: 'string' },
                  packages: {
                    type: 'array',
                    items: { type: 'object' },
                  },
                },
              },
            },
          },
        },
        execute: vi.fn(),
      },
    ];

    const declarations = toGeminiFunctionDeclarations(tools);
    const segmentsProp = declarations[0].parameters?.properties?.segments;

    expect(segmentsProp?.type).toBe('ARRAY');
    expect(segmentsProp?.items).toBeDefined();
    expect(segmentsProp?.items?.type).toBe('OBJECT');
  });

  it('should handle enum values', () => {
    const tools: AgentTool[] = [
      {
        name: 'update_state',
        description: 'Update onboarding state',
        trustTier: 'T1',
        inputSchema: {
          type: 'object',
          properties: {
            phase: {
              type: 'string',
              enum: ['DISCOVERY', 'MARKET_RESEARCH', 'SERVICES', 'MARKETING'],
            },
          },
        },
        execute: vi.fn(),
      },
    ];

    const declarations = toGeminiFunctionDeclarations(tools);
    const phaseProp = declarations[0].parameters?.properties?.phase;

    expect(phaseProp?.enum).toEqual(['DISCOVERY', 'MARKET_RESEARCH', 'SERVICES', 'MARKETING']);
  });
});

// ─────────────────────────────────────────────────────────────────────────────
// Test Suite: Message Conversion
// ─────────────────────────────────────────────────────────────────────────────

describe('6. Chat message conversion', () => {
  it('should convert user messages to Gemini format', () => {
    const messages: ChatMessage[] = [{ role: 'user', content: 'Hello' }];

    const contents = toGeminiContents(messages);

    expect(contents).toHaveLength(1);
    expect(contents[0].role).toBe('user');
    expect(contents[0].parts).toEqual([{ text: 'Hello' }]);
  });

  it('should convert assistant to model role', () => {
    const messages: ChatMessage[] = [{ role: 'assistant', content: 'Hi there!' }];

    const contents = toGeminiContents(messages);

    expect(contents[0].role).toBe('model');
    expect(contents[0].parts).toEqual([{ text: 'Hi there!' }]);
  });

  it('should convert multi-turn conversation', () => {
    const messages: ChatMessage[] = [
      { role: 'user', content: 'Hello' },
      { role: 'assistant', content: 'Hi!' },
      { role: 'user', content: 'What services do you offer?' },
    ];

    const contents = toGeminiContents(messages);

    expect(contents).toHaveLength(3);
    expect(contents[0].role).toBe('user');
    expect(contents[1].role).toBe('model');
    expect(contents[2].role).toBe('user');
  });
});

// ─────────────────────────────────────────────────────────────────────────────
// Test Suite: System Instruction
// ─────────────────────────────────────────────────────────────────────────────

describe('7. System instruction conversion', () => {
  it('should format system prompt as instruction', () => {
    const systemPrompt = 'You are a helpful booking assistant.';

    const instruction = toSystemInstruction(systemPrompt);

    expect(instruction).toEqual({
      parts: [{ text: 'You are a helpful booking assistant.' }],
    });
  });

  it('should handle multi-line system prompts', () => {
    const systemPrompt = `# Assistant Guidelines

You are a booking assistant.

## Rules
- Be helpful
- Be concise`;

    const instruction = toSystemInstruction(systemPrompt);

    expect(instruction.parts[0].text).toContain('# Assistant Guidelines');
    expect(instruction.parts[0].text).toContain('## Rules');
  });
});

// ─────────────────────────────────────────────────────────────────────────────
// Test Suite: Response Parsing Utilities
// ─────────────────────────────────────────────────────────────────────────────

describe('8. Response parsing utilities', () => {
  describe('hasToolCalls', () => {
    it('should return true when functionCall present', () => {
      const response = createMockResponse([{ functionCall: { name: 'test', args: {} } }]);

      expect(hasToolCalls(response)).toBe(true);
    });

    it('should return false for text-only response', () => {
      const response = createMockResponse([{ text: 'Hello!' }]);

      expect(hasToolCalls(response)).toBe(false);
    });

    it('should return false for empty response', () => {
      const response = { candidates: [] } as GenerateContentResponse;

      expect(hasToolCalls(response)).toBe(false);
    });
  });

  describe('extractText', () => {
    it('should extract text from multiple parts', () => {
      const response = createMockResponse([{ text: 'Part 1. ' }, { text: 'Part 2.' }]);

      expect(extractText(response)).toBe('Part 1. Part 2.');
    });

    it('should return empty string for no text', () => {
      const response = createMockResponse([{ functionCall: { name: 'test', args: {} } }]);

      expect(extractText(response)).toBe('');
    });
  });

  describe('extractModelContent', () => {
    it('should extract content for history', () => {
      const response = createMockResponse([
        { text: 'Checking...' },
        { functionCall: { name: 'test', args: {} } },
      ]);

      const content = extractModelContent(response);

      expect(content).not.toBeNull();
      expect(content?.role).toBe('model');
      expect(content?.parts).toHaveLength(2);
    });

    it('should return null for empty response', () => {
      const response = { candidates: [] } as GenerateContentResponse;

      expect(extractModelContent(response)).toBeNull();
    });
  });

  describe('extractUsage', () => {
    it('should extract token counts', () => {
      const response = createMockResponse([{ text: 'Hi' }]);

      const usage = extractUsage(response);

      expect(usage.inputTokens).toBe(100);
      expect(usage.outputTokens).toBe(50);
      expect(usage.totalTokens).toBe(150);
    });

    it('should handle missing usage metadata', () => {
      const response = {
        candidates: [{ content: { role: 'model', parts: [] } }],
      } as GenerateContentResponse;

      const usage = extractUsage(response);

      expect(usage.inputTokens).toBe(0);
      expect(usage.outputTokens).toBe(0);
      expect(usage.totalTokens).toBe(0);
    });
  });
});
