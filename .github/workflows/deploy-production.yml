name: Deploy to Production

on:
  # Trigger AFTER main-pipeline completes successfully on main branch
  workflow_run:
    workflows: ["Main CI/CD Pipeline"]
    branches: [main]
    types: [completed]
  # Direct trigger for version tags (skip duplicate tests)
  push:
    tags:
      - 'v*.*.*'
  # Manual trigger for emergency hotfixes
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
      skip_tests:
        description: 'Skip tests (emergency hotfix only)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      run_migrations:
        description: 'Run database migrations'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

# Prevent concurrent production deployments
concurrency:
  group: deploy-production
  cancel-in-progress: false

env:
  NODE_VERSION: '20'
  PRODUCTION_API_URL: ${{ secrets.PRODUCTION_API_URL }}
  PRODUCTION_CLIENT_URL: ${{ secrets.PRODUCTION_CLIENT_URL }}
  # IPv4 enforcement: handled via PRODUCTION_DATABASE_URL connection string (?family=4).
  # NODE_OPTIONS='--dns-result-order=ipv4first' was removed ‚Äî Prisma's Rust query engine
  # ignores Node.js DNS settings, making the flag a false security signal.

jobs:
  # Job 0: Gate - Only proceed if main-pipeline passed (for workflow_run trigger)
  check-ci-status:
    name: Verify CI Status
    runs-on: ubuntu-latest
    timeout-minutes: 2
    # Skip this check for tags and manual dispatch (they have their own validation)
    if: github.event_name == 'workflow_run'
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}

    steps:
      - name: Check if main-pipeline succeeded
        id: check
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" == "success" ]; then
            echo "‚úÖ Main CI/CD Pipeline passed - proceeding with deployment"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Main CI/CD Pipeline failed - skipping deployment"
            echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  # Job 1: Pre-deployment validation
  pre-deployment-checks:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [check-ci-status]
    # Run if: CI passed (workflow_run), OR it's a tag push, OR it's manual dispatch
    if: |
      always() && (
        (github.event_name == 'workflow_run' && needs.check-ci-status.outputs.should_deploy == 'true') ||
        github.event_name == 'push' ||
        github.event_name == 'workflow_dispatch'
      )

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify version tag (if applicable)
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          echo "Deploying version: $TAG"

          # Verify tag format (v1.2.3)
          if ! [[ $TAG =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ùå Invalid version tag format: $TAG"
            echo "Expected format: v1.2.3"
            exit 1
          fi

          echo "‚úÖ Valid version tag: $TAG"

      - name: Check for breaking changes
        run: |
          echo "üîç Checking for breaking changes in commit messages..."

          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -z "$LAST_TAG" ]; then
            echo "No previous tag found, skipping breaking change check"
            exit 0
          fi

          BREAKING_CHANGES=$(git log $LAST_TAG..HEAD --grep="BREAKING CHANGE" --oneline || echo "")

          if [ -n "$BREAKING_CHANGES" ]; then
            echo "‚ö†Ô∏è  WARNING: Breaking changes detected!"
            echo "$BREAKING_CHANGES"
            echo "Ensure migration strategy is in place"
          else
            echo "‚úÖ No breaking changes detected"
          fi

  # Job 2: Quick sanity tests (only for tags and manual dispatch with tests enabled)
  # NOTE: Tests are SKIPPED for workflow_run because main-pipeline already ran them
  quick-validation:
    name: Quick Validation (Tags/Manual Only)
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [pre-deployment-checks]
    # Only run for: tag pushes OR manual dispatch WITHOUT skip_tests
    if: |
      always() && needs.pre-deployment-checks.result == 'success' && (
        (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')) ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.skip_tests != 'true')
      )

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        # NO continue-on-error - lint failures BLOCK deployment (pitfall #58)
        run: npm run lint

      - name: Run type checking
        run: npm run typecheck

      - name: Build workspace packages
        run: |
          npm run build --workspace=packages/contracts
          npm run build --workspace=packages/shared

  # Job 3: Build for production
  build-production:
    name: Build Production Artifacts
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [pre-deployment-checks, quick-validation]
    # Run if pre-deployment passed AND (quick-validation passed OR was skipped)
    if: |
      always() &&
      needs.pre-deployment-checks.result == 'success' &&
      (needs.quick-validation.result == 'success' || needs.quick-validation.result == 'skipped')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate --schema=./server/prisma/schema.prisma

      - name: Build packages in dependency order
        run: |
          # Build contracts first (web app depends on it)
          npm run build --workspace=packages/contracts
          npm run build --workspace=packages/shared
          # Then build server and Next.js web app
          npm run build --workspace=server
          npm run vercel-build
        env:
          NODE_ENV: production
          # NextAuth v5 requires AUTH_SECRET at build time for page data collection.
          # This is a dummy value for production builds; real secret is used at runtime.
          AUTH_SECRET: production-build-placeholder-not-used-at-runtime

      - name: Upload server build
        uses: actions/upload-artifact@v4
        with:
          name: server-build-production
          path: ./server/dist/
          retention-days: 30

      - name: Upload web app build
        uses: actions/upload-artifact@v4
        with:
          name: web-build-production
          path: ./apps/web/.next/
          retention-days: 30

      - name: Upload contracts build
        uses: actions/upload-artifact@v4
        with:
          name: contracts-build-production
          path: ./packages/contracts/dist/
          retention-days: 30

  # Job 4: Database migration with approval
  migrate-database-production:
    name: Run Database Migrations (Production)
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [build-production]
    if: github.event.inputs.run_migrations != 'false'
    environment:
      name: production-migrations
      url: ${{ env.PRODUCTION_API_URL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run --workspace=server prisma:generate
        env:
          # Prisma 7 requires DATABASE_URL even for generate (to parse schema)
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      - name: Verify database connection
        run: |
          cd server
          npx prisma db execute --stdin < /dev/null
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      - name: Check migration status
        id: migration-status
        run: |
          cd server
          MIGRATION_STATUS=$(npx prisma migrate status --schema=./prisma/schema.prisma 2>&1 || echo "error")

          echo "status<<EOF" >> $GITHUB_OUTPUT
          echo "$MIGRATION_STATUS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          if echo "$MIGRATION_STATUS" | grep -q "No pending migrations"; then
            echo "has_pending=false" >> $GITHUB_OUTPUT
          else
            echo "has_pending=true" >> $GITHUB_OUTPUT
          fi
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      - name: Display migration status
        run: |
          echo "üìä Migration Status:"
          echo "${{ steps.migration-status.outputs.status }}"

          if [ "${{ steps.migration-status.outputs.has_pending }}" == "true" ]; then
            echo "‚ö†Ô∏è  Pending migrations found - will apply"
          else
            echo "‚úÖ No pending migrations"
          fi

      - name: Create pre-migration snapshot notification
        if: steps.migration-status.outputs.has_pending == 'true'
        run: |
          echo "üì∏ IMPORTANT: Verify database backup before proceeding"
          echo "Supabase automatic backups: https://supabase.com/dashboard/project/${{ secrets.SUPABASE_PROJECT_ID }}/settings/backups"
          echo "Consider creating a manual backup for this deployment"

      - name: Run database migrations
        if: steps.migration-status.outputs.has_pending == 'true'
        run: |
          cd server
          npx prisma migrate deploy
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
          DIRECT_URL: ${{ secrets.PRODUCTION_DIRECT_URL }}

      - name: Verify migrations applied
        run: |
          cd server
          npx prisma migrate status --schema=./prisma/schema.prisma
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

  # Job 4b: Seed production database (no approval gate ‚Äî seeds are idempotent)
  seed-database-production:
    name: Seed Production Database
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [build-production, migrate-database-production]
    if: always() && (needs.build-production.result == 'success') && (needs.migrate-database-production.result == 'success' || needs.migrate-database-production.result == 'skipped')
    environment:
      name: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run --workspace=server prisma:generate
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      - name: Seed production database
        run: npm run --workspace=server db:seed:production
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
          ADMIN_DEFAULT_PASSWORD: ${{ secrets.ADMIN_DEFAULT_PASSWORD }}
          ALLOW_PRODUCTION_SEED: 'true'

  # Job 5: Deploy API to Render (Production)
  deploy-api-production:
    name: Deploy API to Production (Render)
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [seed-database-production]
    if: always() && (needs.seed-database-production.result == 'success' || needs.seed-database-production.result == 'skipped')
    environment:
      name: production
      url: ${{ env.PRODUCTION_API_URL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download server build
        uses: actions/download-artifact@v4
        with:
          name: server-build-production
          path: ./server/dist/

      - name: Trigger Render deployment (API)
        id: deploy-api
        run: |
          RESPONSE=$(curl -X POST "${{ secrets.RENDER_PRODUCTION_API_DEPLOY_HOOK }}" \
            -H "Content-Type: application/json" \
            -d '{
              "clearCache": "do_not_clear"
            }')

          echo "response=$RESPONSE" >> $GITHUB_OUTPUT
          echo "Deployment triggered at $(date)"

      - name: Wait for deployment to stabilize
        run: |
          echo "‚è≥ Waiting for Render deployment to complete..."
          sleep 45

      - name: Health check with retries
        run: |
          echo "üè• Running health checks..."

          MAX_ATTEMPTS=30
          ATTEMPT=0
          SUCCESS=false

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))

            if curl -f -s "${{ env.PRODUCTION_API_URL }}/health/ready" > /dev/null; then
              echo "‚úÖ API is healthy (database connected, attempt $ATTEMPT/$MAX_ATTEMPTS)"
              SUCCESS=true
              break
            fi

            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: API not ready yet..."
            sleep 10
          done

          if [ "$SUCCESS" = false ]; then
            echo "‚ùå API health check failed after $MAX_ATTEMPTS attempts"
            echo "Rolling back deployment..."
            exit 1
          fi

      - name: Run production smoke tests
        run: |
          echo "üß™ Running production smoke tests..."

          # Test deep health endpoint (verifies database connectivity)
          HEALTH_RESPONSE=$(curl -f -s "${{ env.PRODUCTION_API_URL }}/health/ready")
          echo "Health check response: $HEALTH_RESPONSE"

          # Verify API serves routes (not just health)
          # NOTE: /v1/packages was removed in Package‚ÜíTier migration (PRs #51-53).
          # Using /health/ready which validates DB connectivity + route serving.
          curl -f -s "${{ env.PRODUCTION_API_URL }}/health/ready" > /dev/null || {
            echo "‚ùå API route serving check failed"
            exit 1
          }

          echo "‚úÖ Production smoke tests passed"

  # Job 6: Deploy Next.js Web App to Vercel (Production)
  deploy-web-production:
    name: Deploy Web App to Production (Vercel)
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [deploy-api-production]
    environment:
      name: production
      url: ${{ env.PRODUCTION_CLIENT_URL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download web app build
        uses: actions/download-artifact@v4
        with:
          name: web-build-production
          path: ./apps/web/.next/

      - name: Deploy to Vercel (Production)
        uses: amondnet/vercel-action@v25
        id: vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod --env NEXT_PUBLIC_API_URL=${{ env.PRODUCTION_API_URL }}'
          working-directory: ./apps/web
          alias-domains: |
            gethandled.ai
            www.gethandled.ai
            app.gethandled.ai

      - name: Wait for Vercel deployment
        run: |
          echo "‚è≥ Waiting for Vercel deployment to propagate..."
          sleep 20

      - name: Verify client deployment
        run: |
          echo "üîç Verifying client is accessible..."

          MAX_ATTEMPTS=20
          ATTEMPT=0
          SUCCESS=false

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))

            if curl -f -s "${{ env.PRODUCTION_CLIENT_URL }}" > /dev/null; then
              echo "‚úÖ Client is accessible (attempt $ATTEMPT/$MAX_ATTEMPTS)"
              SUCCESS=true
              break
            fi

            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Client not ready yet..."
            sleep 5
          done

          if [ "$SUCCESS" = false ]; then
            echo "‚ùå Client verification failed after $MAX_ATTEMPTS attempts"
            exit 1
          fi

  # Job 7: Post-deployment validation
  post-deployment-validation:
    name: Post-Deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: [deploy-web-production]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Run E2E tests against production
        run: npx playwright test
        env:
          CI: true
          BASE_URL: ${{ env.PRODUCTION_CLIENT_URL }}
          API_URL: ${{ env.PRODUCTION_API_URL }}

      - name: Upload E2E test results
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-production-results
          path: |
            playwright-report/
            test-results/
          retention-days: 30

      - name: Create rollback instructions
        if: failure()
        run: |
          cat > ROLLBACK_INSTRUCTIONS.md << 'EOF'
          # Production Deployment Rollback Instructions

          ## Immediate Actions

          1. **Rollback Render API deployment:**
             ```bash
             # Go to Render dashboard
             # Navigate to: https://dashboard.render.com
             # Select the MAIS API service
             # Click "Rollback" to previous deployment
             ```

          2. **Rollback Vercel client deployment:**
             ```bash
             # Use Vercel CLI or dashboard
             vercel rollback ${{ env.PRODUCTION_CLIENT_URL }}
             ```

          3. **Rollback database migrations (if needed):**
             ```bash
             # Connect to production database
             # Review migration history
             npx prisma migrate resolve --rolled-back <migration_name>
             ```

          ## Verification

          - API health: ${{ env.PRODUCTION_API_URL }}/health/ready
          - Client: ${{ env.PRODUCTION_CLIENT_URL }}

          ## Logs

          - View workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          EOF

      - name: Upload rollback instructions
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: rollback-instructions
          path: ROLLBACK_INSTRUCTIONS.md

  # Summary job
  deployment-complete:
    name: Production Deployment Complete
    runs-on: ubuntu-latest
    needs: [deploy-api-production, deploy-web-production, post-deployment-validation]
    if: always()

    steps:
      - name: Check deployment status
        id: check-status
        run: |
          if [ "${{ needs.deploy-api-production.result }}" != "success" ] || \
             [ "${{ needs.deploy-web-production.result }}" != "success" ]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "‚ùå Production deployment failed"
            exit 1
          fi

          if [ "${{ needs.post-deployment-validation.result }}" != "success" ]; then
            echo "status=partial" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Deployment succeeded but validation failed"
            echo "URGENT: Review post-deployment test results"
          else
            echo "status=success" >> $GITHUB_OUTPUT
            echo "‚úÖ Production deployment completed successfully!"
          fi

      - name: Create GitHub Release (on tag)
        if: startsWith(github.ref, 'refs/tags/') && steps.check-status.outputs.status == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const tag = context.ref.replace('refs/tags/', '');
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tag,
              name: `Release ${tag}`,
              body: `## Production Deployment\n\n‚úÖ Successfully deployed to production\n\n- API: ${{ env.PRODUCTION_API_URL }}\n- Client: ${{ env.PRODUCTION_CLIENT_URL }}\n- Deployment time: ${new Date().toISOString()}`,
              draft: false,
              prerelease: false
            });

      - name: Notify team (Slack/Discord)
        if: always()
        run: |
          STATUS="${{ steps.check-status.outputs.status }}"

          if [ "$STATUS" = "success" ]; then
            EMOJI="üöÄ"
            MESSAGE="Production deployment completed successfully!"
          elif [ "$STATUS" = "partial" ]; then
            EMOJI="‚ö†Ô∏è"
            MESSAGE="Production deployed but validation failed - investigate immediately"
          else
            EMOJI="‚ùå"
            MESSAGE="Production deployment failed - review logs"
          fi

          echo "$EMOJI $MESSAGE"
          echo "Production URL: ${{ env.PRODUCTION_CLIENT_URL }}"
          echo "API URL: ${{ env.PRODUCTION_API_URL }}"

          # Add Slack/Discord webhook integration here
          # curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} -d "{"text": "$MESSAGE"}"

      - name: Record deployment
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              description: 'Production deployment via GitHub Actions',
              auto_merge: false,
              required_contexts: []
            });
